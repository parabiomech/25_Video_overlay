<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Overlay Editor (Fast - WebGL)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 { font-size: 1.8em; margin-bottom: 5px; }
        .header p { opacity: 0.9; font-size: 0.9em; }
        .header .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            margin-top: 5px;
        }

        .main-content { padding: 20px; }

        .upload-section {
            border: 2px dashed #bdc3c7;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-section:hover { border-color: #667eea; background: #f7f9fc; }

        .video-container { display: none; }
        .video-container.active { display: block; }

        video {
            width: 100%;
            max-height: 500px;
            background: black;
            border-radius: 8px;
            margin-bottom: 15px;
            display: block;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1em;
        }

        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover { background: #5568d3; }

        .btn-danger { background: #e74c3c; color: white; }
        .btn-danger:hover { background: #c0392b; }

        .btn-success { background: #2ecc71; color: white; }
        .btn-success:hover { background: #27ae60; }

        .tags-section {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag-item {
            display: flex;
            align-items: center;
            background: white;
            border: 1px solid #bdc3c7;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #2c3e50;
            cursor: pointer;
        }

        .tag-item .remove-btn {
            margin-left: 8px;
            color: #e74c3c;
            font-weight: bold;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }

        .step {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #bdc3c7;
            transition: all 0.3s;
        }

        .step.active { background: #667eea; transform: scale(1.2); }

        .threshold-control {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
        }

        .preview-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .preview-box {
            flex: 1;
            min-width: 300px;
            text-align: center;
        }

        .preview-box canvas {
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 8px;
        }

        input[type="range"] {
            width: 80%;
            margin: 15px 0;
        }

        .result-container {
            text-align: center;
            padding: 20px;
        }
        
        #finalCanvas {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
        }
        
        .spinner {
            width: 50px; height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
            border-radius: 10px;
        }

        .perf-info {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 0.85em;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¬ Motion Overlay Editor</h1>
            <p id="stepTitle">Step 1: ì˜¤ë²„ë ˆì´í•  ì‹œì  ì„ íƒ</p>
            <span class="badge">âš¡ WebGL Accelerated</span>
        </div>

        <div class="main-content">
            <div class="step-indicator">
                <div class="step active" id="step1-dot"></div>
                <div class="step" id="step2-dot"></div>
                <div class="step" id="step3-dot"></div>
            </div>

            <!-- Step 1: Selection -->
            <div id="step1-content">
                <div class="upload-section" id="uploadSection" onclick="document.getElementById('videoInput').click()">
                    <h2>ğŸ“‚ ë¹„ë””ì˜¤ ì—´ê¸°</h2>
                    <p>ëª¨ë“  ë¬¼ì²´(ì‚¬ëŒ, ê³µ, ìŠ¤í†¤ ë“±) ì§€ì› | GPU ê°€ì†ìœ¼ë¡œ ë¹ ë¥¸ ì²˜ë¦¬</p>
                    <input type="file" id="videoInput" accept="video/*" style="display: none;">
                </div>

                <div class="video-container" id="videoContainer">
                    <video id="videoPlayer" controls></video>
                    
                    <div class="controls">
                        <button class="btn btn-primary" onclick="addTimepoint()">
                            ğŸ“¸ ì‹œì  ì¶”ê°€ (Space)
                        </button>
                        <button class="btn btn-danger" onclick="clearAll()">
                            ğŸ—‘ï¸ ì´ˆê¸°í™”
                        </button>
                    </div>

                    <div class="tags-section">
                        <h3>ì„ íƒëœ ì‹œì  (<span id="tagCount">0</span>)</h3>
                        <div class="tag-list" id="tagsContainer"></div>
                    </div>

                    <div style="text-align: center;">
                        <button id="toStep2Btn" class="btn btn-success" style="display: none; width: 100%;" onclick="goToStep2()">
                            ë‹¤ìŒ: ê°ì²´ ì¶”ì¶œ ì„¤ì • ğŸ‘‰
                        </button>
                    </div>
                </div>
            </div>

            <!-- Step 2: Extraction Config -->
            <div id="step2-content" style="display: none;">
                <div class="perf-info">
                    âš¡ GPU ê°€ì† í™œì„±í™”: ì‹¤ì‹œê°„ ë¯¸ë¦¬ë³´ê¸° ì„±ëŠ¥ ìµœì í™”
                </div>

                <div class="threshold-control">
                    <h3>ğŸšï¸ ê°ì²´ ê°ì§€ ë¯¼ê°ë„ ì¡°ì ˆ</h3>
                    <p>ë°°ê²½ê³¼ ë¬¼ì²´ë¥¼ êµ¬ë¶„í•˜ëŠ” ë¯¼ê°ë„ë¥¼ ì¡°ì ˆí•˜ì„¸ìš”. ë¬¼ì²´ê°€ í•˜ì–—ê²Œ ì˜ ë³´ì´ë„ë¡ ì„¤ì •í•˜ì„¸ìš”.</p>
                    <p style="font-size: 0.85em; color: #7f8c8d; margin-top: 5px;">ğŸ’¡ ì¶”ì²œ: ì†/ë°œì´ ì˜ ì•ˆë³´ì´ë©´ <strong>5-15</strong>, ì „ì‹ ì´ ëª…í™•í•˜ë©´ <strong>15-30</strong></p>
                    <input type="range" id="thresholdSlider" min="5" max="100" value="15" oninput="updatePreview()">
                    <span id="thresholdValue">15</span>
                </div>

                <div class="preview-container">
                    <div class="preview-box">
                        <h4>ì›ë³¸ (ì²« ë²ˆì§¸ ì‹œì )</h4>
                        <canvas id="previewOriginal"></canvas>
                    </div>
                    <div class="preview-box">
                        <h4>ì¶”ì¶œ ë§ˆìŠ¤í¬ ë¯¸ë¦¬ë³´ê¸°</h4>
                        <canvas id="previewMask"></canvas>
                    </div>
                </div>

                <div class="controls" style="margin-top: 30px;">
                    <button class="btn btn-danger" onclick="goToStep1()">ğŸ‘ˆ ë’¤ë¡œê°€ê¸°</button>
                    <button class="btn btn-success" onclick="generateResult()">ê²°ê³¼ ìƒì„±í•˜ê¸° (ì‚¬ì§„ + ì˜ìƒ) ğŸ‘‰</button>
                </div>
            </div>

            <!-- Step 3: Result -->
            <div id="step3-content" class="result-container" style="display: none;">
                <h2>âœ¨ ê²°ê³¼ í™•ì¸</h2>
                
                <div style="margin: 20px 0;">
                    <h3>ğŸ–¼ï¸ í•©ì„± ì‚¬ì§„</h3>
                    <canvas id="finalCanvas"></canvas>
                    <button class="btn btn-primary" style="margin-top: 10px;" onclick="downloadImage()">
                        ğŸ’¾ ì‚¬ì§„ ì €ì¥
                    </button>
                </div>

                <div style="margin: 40px 0; border-top: 1px solid #eee; padding-top: 20px;">
                    <h3>ğŸ¥ ëª¨ì…˜ íŠ¸ë ˆì¼ ì˜ìƒ</h3>
                    <video id="finalVideo" controls style="width: 100%; max-height: 500px; border-radius: 8px;"></video>
                    <button class="btn btn-primary" style="margin-top: 10px;" onclick="downloadVideo()">
                        ğŸ’¾ ì˜ìƒ ì €ì¥
                    </button>
                </div>

                <div class="perf-info" id="perfStats" style="text-align: left; max-width: 600px; margin: 20px auto;">
                    â±ï¸ ì²˜ë¦¬ ì‹œê°„ í†µê³„ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.
                </div>

                <button class="btn btn-danger" onclick="location.reload()">ğŸ”„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ</button>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <h3 id="loadingText">ì²˜ë¦¬ ì¤‘...</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        <p id="progressText">0%</p>
        <p id="loadingSubtext" style="font-size: 0.9em; opacity: 0.8;"></p>
    </div>

    <!-- Hidden WebGL Canvas -->
    <canvas id="glCanvas" style="display: none;"></canvas>

    <script>
        const video = document.getElementById('videoPlayer');
        const videoInput = document.getElementById('videoInput');
        
        let timepoints = [];
        let backgroundFrame = null;
        let frameData = [];
        let gl = null;
        let glProgram = null;
        let performanceStats = {};

        // ===== WebGL Setup =====
        function initWebGL() {
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
            
            if (!gl) {
                console.warn('WebGL not available, falling back to CPU processing');
                return false;
            }

            // Vertex shader - ë‹¨ìˆœíˆ ì „ì²´ í™”ë©´ ì‚¬ê°í˜•
            const vsSource = `
                attribute vec2 aPosition;
                attribute vec2 aTexCoord;
                varying vec2 vTexCoord;
                void main() {
                    gl_Position = vec4(aPosition, 0.0, 1.0);
                    vTexCoord = aTexCoord;
                }
            `;

            // Fragment shader - ì°¨ë¶„ ê³„ì‚°
            const fsSource = `
                precision mediump float;
                uniform sampler2D uCurrent;
                uniform sampler2D uBackground;
                uniform float uThreshold;
                varying vec2 vTexCoord;
                
                void main() {
                    vec4 current = texture2D(uCurrent, vTexCoord);
                    vec4 background = texture2D(uBackground, vTexCoord);
                    
                    vec3 diff = abs(current.rgb - background.rgb);
                    float avgDiff = (diff.r + diff.g + diff.b) / 3.0;
                    
                    if (avgDiff > uThreshold / 255.0) {
                        gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
                    } else {
                        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                    }
                }
            `;

            const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
            const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);
            
            glProgram = gl.createProgram();
            gl.attachShader(glProgram, vertexShader);
            gl.attachShader(glProgram, fragmentShader);
            gl.linkProgram(glProgram);

            if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                console.error('Unable to initialize shader program:', gl.getProgramInfoLog(glProgram));
                return false;
            }

            // ì „ì²´ í™”ë©´ ì‚¬ê°í˜• ì„¤ì •
            const positions = new Float32Array([
                -1, -1,  1, -1,  -1, 1,
                -1, 1,   1, -1,  1, 1
            ]);
            // Yì¶• ì¢Œí‘œ ìˆ˜ì •: Canvasì™€ ë™ì¼í•œ ë°©í–¥ìœ¼ë¡œ (ìƒí•˜ ë°˜ì „ ì œê±°)
            const texCoords = new Float32Array([
                0, 0,  1, 0,  0, 1,
                0, 1,  1, 0,  1, 1
            ]);

            const posBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

            const texBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);

            gl.useProgram(glProgram);
            
            const posLoc = gl.getAttribLocation(glProgram, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
            gl.enableVertexAttribArray(posLoc);
            gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

            const texLoc = gl.getAttribLocation(glProgram, 'aTexCoord');
            gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
            gl.enableVertexAttribArray(texLoc);
            gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);

            return true;
        }

        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createTexture(gl, image) {
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            return texture;
        }

        function generateMaskWebGL(currentImg, bgImg, threshold, width, height) {
            const canvas = document.getElementById('glCanvas');
            canvas.width = width;
            canvas.height = height;
            gl.viewport(0, 0, width, height);

            // í…ìŠ¤ì²˜ ìƒì„±
            const currentTex = createTexture(gl, currentImg);
            const bgTex = createTexture(gl, bgImg);

            gl.useProgram(glProgram);

            // ìœ ë‹ˆí¼ ì„¤ì •
            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, currentTex);
            gl.uniform1i(gl.getUniformLocation(glProgram, 'uCurrent'), 0);

            gl.activeTexture(gl.TEXTURE1);
            gl.bindTexture(gl.TEXTURE_2D, bgTex);
            gl.uniform1i(gl.getUniformLocation(glProgram, 'uBackground'), 1);

            gl.uniform1f(gl.getUniformLocation(glProgram, 'uThreshold'), threshold);

            // ë Œë”ë§
            gl.drawArrays(gl.TRIANGLES, 0, 6);

            // ê²°ê³¼ ì½ê¸°
            const pixels = new Uint8ClampedArray(width * height * 4);
            gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

            // í…ìŠ¤ì²˜ ì •ë¦¬
            gl.deleteTexture(currentTex);
            gl.deleteTexture(bgTex);

            return new ImageData(pixels, width, height);
        }

        // CPU í´ë°±
        function generateMaskCPU(targetImg, bgImg, threshold, w, h) {
            const c1 = document.createElement('canvas'); 
            c1.width = w; c1.height = h;
            const ctx1 = c1.getContext('2d');
            ctx1.drawImage(targetImg, 0, 0);
            const data1 = ctx1.getImageData(0, 0, w, h).data;

            const c2 = document.createElement('canvas'); 
            c2.width = w; c2.height = h;
            const ctx2 = c2.getContext('2d');
            ctx2.drawImage(bgImg, 0, 0);
            const data2 = ctx2.getImageData(0, 0, w, h).data;

            const result = ctx1.createImageData(w, h);
            const resData = result.data;

            for (let i = 0; i < data1.length; i += 4) {
                const rDiff = Math.abs(data1[i] - data2[i]);
                const gDiff = Math.abs(data1[i+1] - data2[i+1]);
                const bDiff = Math.abs(data1[i+2] - data2[i+2]);
                
                const diff = (rDiff + gDiff + bDiff) / 3;

                if (diff > threshold) {
                    resData[i] = 255;
                    resData[i+1] = 255;
                    resData[i+2] = 255;
                    resData[i+3] = 255;
                } else {
                    resData[i] = 0;
                    resData[i+1] = 0;
                    resData[i+2] = 0;
                    resData[i+3] = 255;
                }
            }
            return result;
        }

        function generateDifferenceMask(targetImg, bgImg, threshold, w, h) {
            if (gl && glProgram) {
                return generateMaskWebGL(targetImg, bgImg, threshold, w, h);
            } else {
                return generateMaskCPU(targetImg, bgImg, threshold, w, h);
            }
        }

        // ===== Step 1: Setup & Selection =====
        videoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                video.src = URL.createObjectURL(file);
                document.getElementById('uploadSection').style.display = 'none';
                document.getElementById('videoContainer').classList.add('active');
                
                // WebGL ì´ˆê¸°í™” (ë¹„ë””ì˜¤ ë¡œë“œ í›„)
                video.addEventListener('loadedmetadata', () => {
                    initWebGL();
                }, { once: true });
            }
        });

        function addTimepoint() {
            const time = video.currentTime;
            if (!timepoints.some(t => Math.abs(t - time) < 0.1)) {
                timepoints.push(time);
                timepoints.sort((a, b) => a - b);
                updateTags();
            }
        }

        function removeTimepoint(index) {
            timepoints.splice(index, 1);
            updateTags();
        }

        function clearAll() {
            timepoints = [];
            updateTags();
        }

        function updateTags() {
            const container = document.getElementById('tagsContainer');
            document.getElementById('tagCount').textContent = timepoints.length;
            container.innerHTML = '';
            
            timepoints.forEach((time, index) => {
                const div = document.createElement('div');
                div.className = 'tag-item';
                div.innerHTML = `<span onclick="video.currentTime=${time}">${time.toFixed(2)}s</span> <span class="remove-btn" onclick="removeTimepoint(${index})">Ã—</span>`;
                container.appendChild(div);
            });

            document.getElementById('toStep2Btn').style.display = timepoints.length > 0 ? 'block' : 'none';
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && video.src && document.getElementById('step1-content').style.display !== 'none') {
                e.preventDefault();
                video.paused ? video.play() : (video.pause(), addTimepoint());
            }
        });

        // ===== Step 2: Extraction Configuration =====
        async function goToStep2() {
            const startTime = performance.now();
            showLoading('í”„ë ˆì„ ì¶”ì¶œ ì¤‘...', 'ì‚¬ì „ ë¡œë”©ìœ¼ë¡œ ì´í›„ ì²˜ë¦¬ ê°€ì†í™”');
            
            // ë°°ê²½ í”„ë ˆì„ ìº¡ì²˜ (0ì´ˆ)
            video.currentTime = 0;
            await waitForSeek();
            backgroundFrame = await captureFrame();

            // ëª¨ë“  ì„ íƒëœ ì‹œì ì˜ í”„ë ˆì„ì„ ë¯¸ë¦¬ ì¶”ì¶œ (ë³‘ë ¬ ì²˜ë¦¬)
            frameData = [];
            for (let i = 0; i < timepoints.length; i++) {
                const time = timepoints[i];
                video.currentTime = time;
                await waitForSeek();
                const frame = await captureFrame();
                frameData.push({ time, frame });
                
                updateLoadingSubtext(`í”„ë ˆì„ ì¶”ì¶œ ì¤‘... ${i + 1}/${timepoints.length}`);
            }

            const extractTime = performance.now() - startTime;
            performanceStats.extractTime = extractTime;

            hideLoading();
            
            // UI ì „í™˜
            document.getElementById('step1-content').style.display = 'none';
            document.getElementById('step2-content').style.display = 'block';
            document.getElementById('stepTitle').textContent = 'Step 2: ê°ì²´ ì¶”ì¶œ ì„¤ì •';
            document.getElementById('step1-dot').classList.remove('active');
            document.getElementById('step2-dot').classList.add('active');

            updatePreview();
        }

        function goToStep1() {
            document.getElementById('step2-content').style.display = 'none';
            document.getElementById('step1-content').style.display = 'block';
            document.getElementById('stepTitle').textContent = 'Step 1: ì˜¤ë²„ë ˆì´í•  ì‹œì  ì„ íƒ';
            document.getElementById('step2-dot').classList.remove('active');
            document.getElementById('step1-dot').classList.add('active');
        }

        function updatePreview() {
            if (frameData.length === 0) return;

            const startTime = performance.now();
            const threshold = parseInt(document.getElementById('thresholdSlider').value);
            document.getElementById('thresholdValue').textContent = threshold;

            const sample = frameData[0];
            const w = video.videoWidth;
            const h = video.videoHeight;

            // ì›ë³¸ ê·¸ë¦¬ê¸°
            const cvsOrig = document.getElementById('previewOriginal');
            cvsOrig.width = w; 
            cvsOrig.height = h;
            cvsOrig.getContext('2d').drawImage(sample.frame, 0, 0);

            // ë§ˆìŠ¤í¬ ìƒì„± (WebGL ê°€ì†)
            const cvsMask = document.getElementById('previewMask');
            cvsMask.width = w; 
            cvsMask.height = h;
            const ctxMask = cvsMask.getContext('2d');
            
            const maskData = generateDifferenceMask(sample.frame, backgroundFrame, threshold, w, h);
            ctxMask.putImageData(maskData, 0, 0);

            const previewTime = performance.now() - startTime;
            console.log(`Preview generated in ${previewTime.toFixed(2)}ms`);
        }

        // ===== Step 3: Generation =====
        async function generateResult() {
            const startTime = performance.now();
            showLoading('ì´ë¯¸ì§€ í•©ì„± ì¤‘...', 'ëª¨ë“  ì‹œì ì„ í•˜ë‚˜ì˜ ì´ë¯¸ì§€ë¡œ í•©ì„±');
            
            const threshold = parseInt(document.getElementById('thresholdSlider').value);
            const w = video.videoWidth;
            const h = video.videoHeight;

            // 1. ì •ì  ì´ë¯¸ì§€ ìƒì„±
            const finalCanvas = document.getElementById('finalCanvas');
            finalCanvas.width = w; 
            finalCanvas.height = h;
            const ctx = finalCanvas.getContext('2d');

            // ë°°ê²½ ê·¸ë¦¬ê¸°
            ctx.drawImage(backgroundFrame, 0, 0);

            // ê° ì‹œì ì˜ ê°ì²´ ì˜¤ë²„ë ˆì´
            for (let i = 0; i < frameData.length; i++) {
                const item = frameData[i];
                updateLoadingSubtext(`ê°ì²´ ì¶”ì¶œ ì¤‘... ${i + 1}/${frameData.length}`);
                
                const mask = generateDifferenceMask(item.frame, backgroundFrame, threshold, w, h);
                applyMaskAndDraw(ctx, item.frame, mask, w, h);
                
                // UI ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ì‘ì€ ì§€ì—°
                await new Promise(r => setTimeout(r, 10));
            }

            const imageTime = performance.now() - startTime;
            performanceStats.imageTime = imageTime;

            // 2. ì˜ìƒ ìƒì„±
            showLoading('ì˜ìƒ ìƒì„± ì¤‘...', 'ìµœì í™”ëœ ìŠ¤íŠ¸ë¦¼ ë Œë”ë§');
            const videoStartTime = performance.now();
            
            await generateVideoFast(threshold, w, h);
            
            const videoTime = performance.now() - videoStartTime;
            performanceStats.videoTime = videoTime;
            performanceStats.totalTime = performance.now() - startTime;

            hideLoading();
            
            // ì„±ëŠ¥ í†µê³„ í‘œì‹œ
            displayPerformanceStats();

            // UI ì „í™˜
            document.getElementById('step2-content').style.display = 'none';
            document.getElementById('step3-content').style.display = 'block';
            document.getElementById('stepTitle').textContent = 'Step 3: ê²°ê³¼ í™•ì¸';
            document.getElementById('step2-dot').classList.remove('active');
            document.getElementById('step3-dot').classList.add('active');
        }

        function applyMaskAndDraw(targetCtx, sourceImg, maskData, w, h) {
            const tempC = document.createElement('canvas');
            tempC.width = w; 
            tempC.height = h;
            const tempCtx = tempC.getContext('2d');
            
            tempCtx.drawImage(sourceImg, 0, 0);
            const sourceData = tempCtx.getImageData(0, 0, w, h);
            
            // ë§ˆìŠ¤í¬ ì ìš©
            for (let i = 0; i < sourceData.data.length; i += 4) {
                if (maskData.data[i] === 0) {
                    sourceData.data[i+3] = 0;
                }
            }
            
            tempCtx.putImageData(sourceData, 0, 0);
            
            targetCtx.globalAlpha = 0.8;
            targetCtx.drawImage(tempC, 0, 0);
            targetCtx.globalAlpha = 1.0;
        }

        async function generateVideoFast(threshold, w, h) {
            const canvas = document.createElement('canvas');
            canvas.width = w; 
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            
            const stream = canvas.captureStream(30);
            const mediaRecorder = new MediaRecorder(stream, { 
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 5000000
            });
            const chunks = [];
            
            mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
            mediaRecorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const videoUrl = URL.createObjectURL(blob);
                document.getElementById('finalVideo').src = videoUrl;
                window.finalVideoBlob = blob;
            };
            
            mediaRecorder.start();

            // ì˜¤ë²„ë ˆì´ ì‚¬ì „ ìƒì„± (WebGL ê°€ì†)
            const overlays = [];
            for (let item of frameData) {
                const mask = generateDifferenceMask(item.frame, backgroundFrame, threshold, w, h);
                const tempC = document.createElement('canvas');
                tempC.width = w; 
                tempC.height = h;
                const tCtx = tempC.getContext('2d');
                tCtx.drawImage(item.frame, 0, 0);
                const sData = tCtx.getImageData(0, 0, w, h);
                
                for(let i = 0; i < sData.data.length; i += 4) {
                    if(mask.data[i] === 0) sData.data[i+3] = 0;
                }
                
                tCtx.putImageData(sData, 0, 0);
                overlays.push({ time: item.time, img: tempC });
            }

            // ì˜ìƒ ì¬ìƒí•˜ë©° ì‹¤ì‹œê°„ ë Œë”ë§
            video.currentTime = 0;
            await waitForSeek();
            
            const duration = video.duration;
            const fps = 30;
            const frameTime = 1000 / fps;
            let currentTime = 0;
            let frameCount = 0;
            const totalFrames = Math.floor(duration * fps);

            return new Promise((resolve) => {
                function renderFrame() {
                    if (currentTime >= duration) {
                        mediaRecorder.stop();
                        resolve();
                        return;
                    }

                    // í˜„ì¬ ë¹„ë””ì˜¤ í”„ë ˆì„ ê·¸ë¦¬ê¸°
                    ctx.drawImage(video, 0, 0);
                    
                    // ì§€ë‚˜ê°„ ì‹œì ì˜ ì˜¤ë²„ë ˆì´ ëˆ„ì 
                    for (let ov of overlays) {
                        if (currentTime >= ov.time) {
                            ctx.globalAlpha = 0.8;
                            ctx.drawImage(ov.img, 0, 0);
                            ctx.globalAlpha = 1.0;
                        }
                    }

                    currentTime += 1/fps;
                    frameCount++;
                    
                    const progress = Math.floor(frameCount / totalFrames * 100);
                    if (frameCount % 10 === 0) {
                        updateProgress(progress, `${progress}%`);
                        updateLoadingSubtext(`ì˜ìƒ ë Œë”ë§ ì¤‘...`);
                    }

                    // ë‹¤ìŒ í”„ë ˆì„ìœ¼ë¡œ ì´ë™
                    video.currentTime = currentTime;
                    
                    // requestAnimationFrame ëŒ€ì‹  ê³ ì • ê°„ê²© ì‚¬ìš©
                    setTimeout(renderFrame, frameTime);
                }

                renderFrame();
            });
        }

        // ===== Helpers =====
        function waitForSeek() {
            return new Promise(resolve => {
                const handler = () => {
                    video.removeEventListener('seeked', handler);
                    resolve();
                };
                video.addEventListener('seeked', handler);
            });
        }

        async function captureFrame() {
            return createImageBitmap(video);
        }

        function showLoading(msg, subtext = '') {
            document.getElementById('loadingText').textContent = msg;
            document.getElementById('loadingSubtext').textContent = subtext;
            document.getElementById('loadingOverlay').style.display = 'flex';
            updateProgress(0, '0%');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function updateLoadingSubtext(text) {
            document.getElementById('loadingSubtext').textContent = text;
        }
        
        function updateProgress(percent, text) {
            const fill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            if (fill) fill.style.width = percent + '%';
            if (progressText) progressText.textContent = text || (percent + '%');
        }

        function displayPerformanceStats() {
            const stats = performanceStats;
            const html = `
                â±ï¸ <strong>ì²˜ë¦¬ ì‹œê°„ í†µê³„</strong><br>
                â€¢ í”„ë ˆì„ ì¶”ì¶œ: ${(stats.extractTime / 1000).toFixed(2)}ì´ˆ<br>
                â€¢ ì´ë¯¸ì§€ í•©ì„±: ${(stats.imageTime / 1000).toFixed(2)}ì´ˆ<br>
                â€¢ ì˜ìƒ ìƒì„±: ${(stats.videoTime / 1000).toFixed(2)}ì´ˆ<br>
                â€¢ <strong>ì´ ì²˜ë¦¬ ì‹œê°„: ${(stats.totalTime / 1000).toFixed(2)}ì´ˆ</strong><br>
                â€¢ ê°€ì† ë°©ì‹: ${gl ? 'WebGL GPU' : 'CPU'}
            `;
            document.getElementById('perfStats').innerHTML = html;
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'overlay_result.png';
            link.href = document.getElementById('finalCanvas').toDataURL();
            link.click();
        }

        function downloadVideo() {
            if (window.finalVideoBlob) {
                const link = document.createElement('a');
                link.download = 'motion_trail.webm';
                link.href = URL.createObjectURL(window.finalVideoBlob);
                link.click();
            }
        }
    </script>
</body>
</html>
