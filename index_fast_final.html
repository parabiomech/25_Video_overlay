<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Overlay Editor (Optimized - Final)</title>
    <script src="https://docs.opencv.org/4.8.0/opencv.js" async onload="onOpenCvReady()"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.9em;
        }

        .header .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            margin-top: 5px;
        }

        .main-content {
            padding: 20px;
        }

        .upload-section {
            border: 2px dashed #bdc3c7;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-section:hover {
            border-color: #667eea;
            background: #f7f9fc;
        }

        .video-container {
            display: none;
            margin-bottom: 20px;
            text-align: center;
        }

        .video-container.active {
            display: block;
        }

        /* Video Wrapper: Shrink to fit video content exactly */
        .video-wrapper {
            position: relative;
            display: inline-block;
            /* Wraps tightly around content */
            width: auto;
            max-width: 100%;
            background: black;
            border-radius: 8px;
            overflow: hidden;
            line-height: 0;
            /* Remove vertical space */
        }

        video {
            max-width: 100%;
            max-height: 60vh;
            /* Responsive height */
            display: block;
        }

        #roiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            cursor: crosshair;
            z-index: 10;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1em;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background: #27ae60;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .tags-section {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: left;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag-item {
            display: flex;
            align-items: center;
            background: white;
            border: 1px solid #bdc3c7;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #2c3e50;
            cursor: pointer;
        }

        .tag-item .remove-btn {
            margin-left: 8px;
            color: #e74c3c;
            font-weight: bold;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }

        .step {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #bdc3c7;
            transition: all 0.3s;
        }

        .step.active {
            background: #667eea;
            transform: scale(1.2);
        }

        .config-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .config-group {
            margin-bottom: 15px;
        }

        .config-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .config-group input[type="range"] {
            width: 100%;
        }

        .preview-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .preview-box {
            flex: 1;
            min-width: 300px;
            text-align: center;
        }

        .preview-box canvas {
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #000;
        }

        .result-container {
            text-align: center;
            padding: 20px;
        }

        #finalCanvas {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s;
            border-radius: 10px;
        }

        .perf-info {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 0.85em;
        }

        #roiInfo {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            pointer-events: none;
            display: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ Motion Overlay (Optimized)</h1>
            <p id="stepTitle">Step 1: Ïò§Î≤ÑÎ†àÏù¥Ìï† ÏãúÏ†ê Î∞è ROI ÏÑ†ÌÉù</p>
            <span class="badge" id="opencvStatus">‚è≥ Loading OpenCV...</span>
        </div>

        <div class="main-content">
            <div class="step-indicator">
                <div class="step active" id="step1-dot"></div>
                <div class="step" id="step2-dot"></div>
                <div class="step" id="step3-dot"></div>
            </div>

            <!-- Step 1: Selection & ROI -->
            <div id="step1-content">
                <div class="upload-section" id="uploadSection" onclick="document.getElementById('videoInput').click()">
                    <h2>üìÇ ÎπÑÎîîÏò§ Ïó¥Í∏∞</h2>
                    <p>OpenCV.js Í∏∞Î∞ò ÏµúÏ†ÅÌôî | ROI, HSV/YCbCr ÏßÄÏõê</p>
                    <input type="file" id="videoInput" accept="video/*" style="display: none;">
                </div>

                <div class="video-container" id="videoContainer">
                    <div class="video-wrapper">
                        <video id="videoPlayer" playsinline></video>
                        <canvas id="roiCanvas"></canvas>
                        <div id="roiInfo">ROI: Ï†ÑÏ≤¥ ÌôîÎ©¥</div>
                    </div>

                    <div class="controls">
                        <button class="btn btn-secondary" onclick="toggleRoiMode()">
                            üìê ROI ÏßÄÏ†ï (ÏºúÍ∏∞/ÎÅÑÍ∏∞)
                        </button>
                        <button class="btn btn-primary" onclick="addTimepoint()">
                            üì∏ ÏãúÏ†ê Ï∂îÍ∞Ä (Space)
                        </button>
                        <button class="btn btn-danger" onclick="clearAll()">
                            üóëÔ∏è Ï¥àÍ∏∞Ìôî
                        </button>
                    </div>

                    <div class="tags-section">
                        <h3>ÏÑ†ÌÉùÎêú ÏãúÏ†ê (<span id="tagCount">0</span>)</h3>
                        <div class="tag-list" id="tagsContainer"></div>
                        <p style="font-size: 0.8em; color: #666; margin-top: 5px;">* ÏãúÏ†êÏùÑ 3Í∞ú Ïù¥ÏÉÅ ÏÑ†ÌÉùÌïòÎ©¥ Îçî Ï¢ãÏùÄ Í≤∞Í≥ºÎ•º ÏñªÏùÑ Ïàò ÏûàÏäµÎãàÎã§
                            (Spacebar)</p>
                    </div>

                    <div style="text-align: center;">
                        <button id="toStep2Btn" class="btn btn-success" style="display: none; width: 100%;"
                            onclick="goToStep2()">
                            Îã§Ïùå: ÌååÎùºÎØ∏ÌÑ∞ ÏÑ§Ï†ï üëâ
                        </button>
                    </div>
                </div>
            </div>

            <!-- Step 2: Config -->
            <div id="step2-content" style="display: none;">
                <div class="perf-info">
                    üõ†Ô∏è Ï≤òÎ¶¨ ÏïåÍ≥†Î¶¨Ï¶ò: Downsample(50%) ‚Üí ROI ‚Üí YCbCr Diff ‚Üí HSV Check ‚Üí Close/Open ‚Üí Contour
                </div>

                <div class="config-panel">
                    <div class="config-group">
                        <label>ÌÉêÏÉâ ÎØºÍ∞êÎèÑ (Threshold): <span id="threshVal">30</span></label>
                        <input type="range" id="thresholdRange" min="5" max="100" value="30" oninput="updatePreview()">
                    </div>
                    <div class="config-group">
                        <label>ÎÖ∏Ïù¥Ï¶à Ï†úÍ±∞ (Morphology): <span id="morphVal">2</span></label>
                        <input type="range" id="morphRange" min="0" max="10" value="2" oninput="updatePreview()">
                    </div>
                </div>

                <div class="preview-container">
                    <div class="preview-box">
                        <h4>ROI ÎØ∏Î¶¨Î≥¥Í∏∞</h4>
                        <canvas id="previewRoi"></canvas>
                    </div>
                    <div class="preview-box">
                        <h4>Ï≤òÎ¶¨ Í≤∞Í≥º (ÏÑ†/Ï†ê Ï∂îÏ∂ú)</h4>
                        <canvas id="previewProc"></canvas>
                    </div>
                </div>

                <div class="controls" style="margin-top: 30px;">
                    <button class="btn btn-danger" onclick="goToStep1()">üëà Îí§Î°úÍ∞ÄÍ∏∞</button>
                    <button class="btn btn-success" onclick="generateResult()">Í≤∞Í≥º ÏÉùÏÑ±ÌïòÍ∏∞ (Ïò§Î≤ÑÎ†àÏù¥ Ìï©ÏÑ±) üëâ</button>
                </div>
            </div>

            <!-- Step 3: Result -->
            <div id="step3-content" class="result-container" style="display: none;">
                <h2>‚ú® Í≤∞Í≥º ÌôïÏù∏</h2>

                <div style="margin: 20px 0;">
                    <h3>üñºÔ∏è Ìï©ÏÑ± Í≤∞Í≥º</h3>
                    <canvas id="finalCanvas"></canvas>
                    <button class="btn btn-primary" style="margin-top: 10px;" onclick="downloadImage()">
                        üíæ ÏÇ¨ÏßÑ Ï†ÄÏû•
                    </button>
                </div>

                <button class="btn btn-danger" onclick="location.reload()">üîÑ Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú</button>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <h3 id="loadingText">Ï≤òÎ¶¨ Ï§ë...</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        <p id="progressText">0%</p>
        <p id="loadingSubtext" style="font-size: 0.9em; opacity: 0.8;"></p>
    </div>

    <script>
        // Global State
        const video = document.getElementById('videoPlayer');
        const roiCanvas = document.getElementById('roiCanvas');
        let timepoints = [];
        let cvReady = false;

        let roiRect = null; // {x, y, w, h} normalized (0~1)
        let isSelectingRoi = false;
        let isRoiMode = false;
        let startX, startY;

        let backgroundFrameData = null; // ImageData for CV
        let frameDataList = []; // Array of {time, imageData}

        // OpenCV init check
        function onOpenCvReady() {
            cvReady = true;
            document.getElementById('opencvStatus').textContent = '‚úÖ OpenCV Ready';
            document.getElementById('opencvStatus').style.background = 'rgba(46, 204, 113, 0.2)';
            document.getElementById('opencvStatus').style.color = '#27ae60';
            console.log("OpenCV.js loaded");
        }

        // ===== Step 1 Video & ROI =====
        document.getElementById('videoInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                video.src = url;
                document.getElementById('uploadSection').style.display = 'none';
                document.getElementById('videoContainer').classList.add('active');

                video.onloadedmetadata = () => {
                    syncCanvasSize();
                };
            }
        });

        function syncCanvasSize() {
            if (video.videoWidth) {
                // Ensure the canvas matches the displayed size of the video exactly
                // Since wrapper wraps video tightly, we can use video dimensions
                roiCanvas.width = video.clientWidth;
                roiCanvas.height = video.clientHeight;
                drawRoiBox();
            }
        }

        window.addEventListener('resize', syncCanvasSize);

        // ROI Selection Logic
        function toggleRoiMode() {
            if (!video.src) return;
            isRoiMode = !isRoiMode;
            roiCanvas.style.pointerEvents = isRoiMode ? 'auto' : 'none';
            roiCanvas.style.cursor = isRoiMode ? 'crosshair' : 'default';
            const btn = document.querySelector('.controls .btn-secondary');

            if (isRoiMode) {
                btn.style.background = '#e67e22';
                btn.textContent = 'üìê ROI ÏôÑÎ£å';
                document.getElementById('roiInfo').style.display = 'block';
                syncCanvasSize();
            } else {
                btn.style.background = '#95a5a6';
                btn.textContent = 'üìê ROI ÏßÄÏ†ï (ÏºúÍ∏∞/ÎÅÑÍ∏∞)';
            }
        }

        roiCanvas.addEventListener('mousedown', e => {
            if (!isRoiMode) return;
            isSelectingRoi = true;
            const rect = roiCanvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
        });

        roiCanvas.addEventListener('mousemove', e => {
            if (!isSelectingRoi || !isRoiMode) return;
            const rect = roiCanvas.getBoundingClientRect();
            const currX = e.clientX - rect.left;
            const currY = e.clientY - rect.top;

            const ctx = roiCanvas.getContext('2d');
            ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);

            // Draw current selection
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.strokeRect(startX, startY, currX - startX, currY - startY);
        });

        roiCanvas.addEventListener('mouseup', e => {
            if (!isSelectingRoi || !isRoiMode) return;
            isSelectingRoi = false;

            const rect = roiCanvas.getBoundingClientRect();
            const currX = e.clientX - rect.left;
            const currY = e.clientY - rect.top;

            // Calculate ROI
            let x = Math.min(startX, currX);
            let y = Math.min(startY, currY);
            let w = Math.abs(currX - startX);
            let h = Math.abs(currY - startY);

            if (w > 10 && h > 10) {
                roiRect = {
                    x: x / roiCanvas.width,
                    y: y / roiCanvas.height,
                    w: w / roiCanvas.width,
                    h: h / roiCanvas.height
                };

                // Clamp 0-1
                roiRect.x = Math.max(0, Math.min(1, roiRect.x));
                roiRect.y = Math.max(0, Math.min(1, roiRect.y));
                roiRect.w = Math.min(1 - roiRect.x, roiRect.w);
                roiRect.h = Math.min(1 - roiRect.y, roiRect.h);

                document.getElementById('roiInfo').textContent = `ROI: ${Math.round(roiRect.w * 100)}% x ${Math.round(roiRect.h * 100)}%`;
            } else {
                roiRect = null;
                document.getElementById('roiInfo').textContent = `ROI: Ï†ÑÏ≤¥ ÌôîÎ©¥`;
                const ctx = roiCanvas.getContext('2d');
                ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);
            }
            drawRoiBox();
        });

        function drawRoiBox() {
            const ctx = roiCanvas.getContext('2d');
            ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);
            if (roiRect) {
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(
                    roiRect.x * roiCanvas.width,
                    roiRect.y * roiCanvas.height,
                    roiRect.w * roiCanvas.width,
                    roiRect.h * roiCanvas.height
                );
                ctx.setLineDash([]);
            }
        }

        // Timepoint logic
        function addTimepoint() {
            if (!video.src) return;
            const time = video.currentTime;
            // Avoid duplicates
            if (!timepoints.some(t => Math.abs(t - time) < 0.1)) {
                timepoints.push(time);
                timepoints.sort((a, b) => a - b);
                updateTags();
            }
        }

        function clearAll() {
            timepoints = [];
            updateTags();
            roiRect = null;
            drawRoiBox();
            document.getElementById('roiInfo').textContent = `ROI: Ï†ÑÏ≤¥ ÌôîÎ©¥`;
        }

        function removeTimepoint(index) {
            timepoints.splice(index, 1);
            updateTags();
        }

        function updateTags() {
            const container = document.getElementById('tagsContainer');
            document.getElementById('tagCount').textContent = timepoints.length;
            container.innerHTML = '';
            timepoints.forEach((time, index) => {
                const div = document.createElement('div');
                div.className = 'tag-item';
                div.innerHTML = `<span onclick="video.currentTime=${time}">${time.toFixed(2)}s</span> <span class="remove-btn" onclick="removeTimepoint(${index})">√ó</span>`;
                container.appendChild(div);
            });
            document.getElementById('toStep2Btn').style.display = timepoints.length > 0 ? 'block' : 'none';
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && video.src && document.getElementById('step1-content').style.display !== 'none') {
                e.preventDefault();
                video.paused ? video.play() : (video.pause(), addTimepoint());
            }
        });

        // ===== Step 2 & Processing =====
        async function goToStep2() {
            if (!cvReady) {
                alert('OpenCVÍ∞Ä ÏïÑÏßÅ Î°úÎìúÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ïû†ÏãúÎßå Í∏∞Îã§Î†§Ï£ºÏÑ∏Ïöî. (Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ ÌôïÏù∏)');
                return;
            }

            try {
                showLoading('ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú Ï§ë...');

                // 1. Capture Background (Frame 0)
                video.currentTime = 0;
                await waitForSeek();
                backgroundFrameData = await captureFrameImageData();

                // 2. Capture Target Frames
                frameDataList = [];
                for (let i = 0; i < timepoints.length; i++) {
                    video.currentTime = timepoints[i];
                    await waitForSeek();
                    const data = await captureFrameImageData();
                    frameDataList.push({ time: timepoints[i], data: data });
                    updateProgress((i + 1) / timepoints.length * 100);
                }

                hideLoading();

                // UI Transition
                document.getElementById('step1-content').style.display = 'none';
                document.getElementById('step2-content').style.display = 'block';
                document.getElementById('step1-dot').classList.remove('active');
                document.getElementById('step2-dot').classList.add('active');

                // Trigger preview
                requestAnimationFrame(updatePreview);

            } catch (err) {
                console.error(err);
                hideLoading();
                alert('Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò Î∞úÏÉù: ' + err);
            }
        }

        function goToStep1() {
            document.getElementById('step2-content').style.display = 'none';
            document.getElementById('step1-content').style.display = 'block';
            document.getElementById('step2-dot').classList.remove('active');
            document.getElementById('step1-dot').classList.add('active');
        }

        // Helper: Capture ImageData from Video
        function captureFrameImageData() {
            return new Promise(resolve => {
                const tempC = document.createElement('canvas');
                // Use actual video dimensions
                tempC.width = video.videoWidth;
                tempC.height = video.videoHeight;
                const ctx = tempC.getContext('2d');
                ctx.drawImage(video, 0, 0, tempC.width, tempC.height);
                resolve(ctx.getImageData(0, 0, tempC.width, tempC.height));
            });
        }

        function waitForSeek() {
            return new Promise((resolve, reject) => {
                // If already there
                if (video.seeking) {
                    // fall through to listener
                } else if (video.readyState >= 3) { // HAVE_FUTURE_DATA
                    // Just wait a tiny bit to ensure frame update
                    // setTimeout(resolve, 50); 
                    // return;
                }

                const onSeeked = () => {
                    video.removeEventListener('seeked', onSeeked);
                    resolve();
                };
                video.addEventListener('seeked', onSeeked);

                // Fallback
                setTimeout(() => {
                    video.removeEventListener('seeked', onSeeked);
                    resolve(); // Force proceed
                }, 1500);
            });
        }

        // ===== CORE ALGORITHM =====
        function processFrame(srcData, bgData, threshold, morphIter) {
            let src = null, bg = null;
            let srcYCrCb = null, bgYCrCb = null, diff = null;
            let channels = null, mask = null, temp1 = null, temp2 = null;
            let contours = null, hierarchy = null, M = null;

            try {
                // Setup Mats
                src = cv.matFromImageData(srcData);
                bg = cv.matFromImageData(bgData);

                // 1. Downsample (50% speedup)
                let dsize = new cv.Size(Math.round(src.cols * 0.5), Math.round(src.rows * 0.5));
                cv.resize(src, src, dsize, 0, 0, cv.INTER_AREA);
                cv.resize(bg, bg, dsize, 0, 0, cv.INTER_AREA);

                let w = src.cols;
                let h = src.rows;

                // 2. ROI 
                let roiX = 0, roiY = 0;
                if (roiRect) {
                    roiX = Math.floor(roiRect.x * w);
                    roiY = Math.floor(roiRect.y * h);
                    let roiW = Math.floor(roiRect.w * w);
                    let roiH = Math.floor(roiRect.h * h);

                    roiW = Math.max(1, Math.min(roiW, w - roiX));
                    roiH = Math.max(1, Math.min(roiH, h - roiY));

                    let rect = new cv.Rect(roiX, roiY, roiW, roiH);
                    let srcRoi = src.roi(rect);
                    let bgRoi = bg.roi(rect);

                    // MUST delete originals if we don't need them, but they are src/bg
                    // To be safe in JS opencv, better to just create new handles
                    let oldSrc = src; let oldBg = bg;
                    src = srcRoi; bg = bgRoi;
                    // oldSrc.delete(); // Can't delete parent while using child ROI? 
                    // Actually in OpenCV C++ ROI is ref, in JS it's complicated.
                    // It's safer to clone if we want to delete parent, OR just keep parent alive.
                    // Let's keep parent alive and just work on ROI mat.
                }

                // 3. YCbCr
                srcYCrCb = new cv.Mat();
                bgYCrCb = new cv.Mat();
                cv.cvtColor(src, srcYCrCb, cv.COLOR_RGB2YCrCb);
                cv.cvtColor(bg, bgYCrCb, cv.COLOR_RGB2YCrCb);

                diff = new cv.Mat();
                cv.absdiff(srcYCrCb, bgYCrCb, diff);

                channels = new cv.MatVector();
                cv.split(diff, channels);

                // 4. Threshold (Cb/Cr)
                mask = new cv.Mat();
                temp1 = new cv.Mat();
                temp2 = new cv.Mat();

                // Cr(1), Cb(2)
                cv.threshold(channels.get(1), temp1, threshold, 255, cv.THRESH_BINARY);
                cv.threshold(channels.get(2), temp2, threshold, 255, cv.THRESH_BINARY);
                cv.bitwise_or(temp1, temp2, mask);

                // 5. Morphology
                let kSize = 3;
                M = cv.Mat.ones(kSize, kSize, cv.CV_8U);
                let anchor = new cv.Point(-1, -1);

                cv.morphologyEx(mask, mask, cv.MORPH_OPEN, M, anchor, morphIter);
                cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, M, anchor, morphIter);

                // 6. Contours
                contours = new cv.MatVector();
                hierarchy = new cv.Mat();
                cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let maxArea = 0;
                let maxIdx = -1;

                for (let i = 0; i < contours.size(); i++) {
                    let cnt = contours.get(i);
                    let area = cv.contourArea(cnt);
                    if (area > maxArea) {
                        maxArea = area;
                        maxIdx = i;
                    }
                }

                let result = {
                    found: false,
                    center: null,
                    endpoints: [],
                    roiOffset: { x: roiX, y: roiY }, // in processed coordinate space
                    // We must pass the original source mats for cleanup if we used ROIs
                    // Actually we let 'finally' block handle null checks.
                    scale: 2.0
                };

                if (maxIdx !== -1 && maxArea > 50) {
                    let maxCnt = contours.get(maxIdx);
                    result.found = true;

                    let rotRect = cv.minAreaRect(maxCnt);
                    result.center = rotRect.center;

                    // Endpoints from Rotated Rect
                    // Axis of the body is often the longer dimension
                    let vertices = cv.RotatedRect.points(rotRect);

                    // Distances
                    let d1 = Math.hypot(vertices[0].x - vertices[1].x, vertices[0].y - vertices[1].y);
                    let d2 = Math.hypot(vertices[1].x - vertices[2].x, vertices[1].y - vertices[2].y);

                    // We want endpoints of the major axis.
                    // Major axis passes through center and bisects the shorter sides.
                    let p1, p2;
                    if (d2 > d1) { // 1-2 is longer side. Major axis is parallel to 1-2.
                        // It connects midpoints of 0-1 and 2-3.
                        p1 = { x: (vertices[0].x + vertices[1].x) / 2, y: (vertices[0].y + vertices[1].y) / 2 };
                        p2 = { x: (vertices[2].x + vertices[3].x) / 2, y: (vertices[2].y + vertices[3].y) / 2 };
                    } else { // 0-1 is longer side.
                        p1 = { x: (vertices[1].x + vertices[2].x) / 2, y: (vertices[1].y + vertices[2].y) / 2 };
                        p2 = { x: (vertices[3].x + vertices[0].x) / 2, y: (vertices[3].y + vertices[0].y) / 2 };
                    }
                    result.endpoints = [p1, p2];
                }

                return result;

            } catch (e) {
                console.error("OpenCV processing failed", e);
                return { found: false };
            } finally {
                // Explicit deletion
                if (src && !src.isDeleted()) src.delete();
                // if we had oldSrc (parent of roi), technically we should delete it too?
                // JS GC handles JS objects, but OpenCV mats need delete.
                if (bg && !bg.isDeleted()) bg.delete();
                if (srcYCrCb) srcYCrCb.delete();
                if (bgYCrCb) bgYCrCb.delete();
                if (diff) diff.delete();
                if (channels) channels.delete();
                if (mask) mask.delete();
                if (temp1) temp1.delete();
                if (temp2) temp2.delete();
                if (contours) contours.delete();
                if (hierarchy) hierarchy.delete();
                if (M) M.delete();
            }
        }

        function updatePreview() {
            if (frameDataList.length === 0) return;
            const threshold = parseInt(document.getElementById('thresholdRange').value);
            const morph = parseInt(document.getElementById('morphRange').value);
            document.getElementById('threshVal').textContent = threshold;
            document.getElementById('morphVal').textContent = morph;

            // Use first frame
            const res = processFrame(frameDataList[0].data, backgroundFrameData, threshold, morph);

            // Draw Process result
            const procC = document.getElementById('previewProc');
            procC.width = video.videoWidth; procC.height = video.videoHeight;
            const pCtx = procC.getContext('2d');
            pCtx.fillStyle = '#000';
            pCtx.fillRect(0, 0, procC.width, procC.height);

            if (res.found) {
                drawFeature(pCtx, res);
            }

            // Draw ROI on the original frame preview
            const roiC = document.getElementById('previewRoi');
            roiC.width = video.videoWidth; roiC.height = video.videoHeight;
            const rCtx = roiC.getContext('2d');
            rCtx.putImageData(frameDataList[0].data, 0, 0);

            if (roiRect) {
                rCtx.strokeStyle = 'yellow';
                rCtx.lineWidth = 4;
                rCtx.strokeRect(roiRect.x * roiC.width, roiRect.y * roiC.height, roiRect.w * roiC.width, roiRect.h * roiC.height);
            }
        }

        function drawFeature(ctx, res) {
            const scale = res.scale;
            const ox = res.roiOffset ? res.roiOffset.x : 0;
            const oy = res.roiOffset ? res.roiOffset.y : 0;

            function toOrig(p) {
                return {
                    x: (p.x * scale) + (ox * scale),
                    y: (p.y * scale) + (oy * scale)
                };
            }

            if (res.endpoints.length === 2) {
                const p1 = toOrig(res.endpoints[0]);
                const p2 = toOrig(res.endpoints[1]);

                ctx.beginPath();
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 4;
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                ctx.fillStyle = '#ff0000';
                for (let p of [p1, p2]) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            if (res.center) {
                const c = toOrig(res.center);
                ctx.fillStyle = '#00ffff';
                ctx.beginPath();
                ctx.arc(c.x, c.y, 5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ===== Step 3 Generation =====
        function generateResult() {
            showLoading('Í≤∞Í≥º ÏÉùÏÑ± Ï§ë...', 'Î∂ÑÏÑù Î∞è Ïò§Î≤ÑÎ†àÏù¥ ÎìúÎ°úÏûâ');

            // Use setTimeout to allow UI to update
            setTimeout(() => {
                const threshold = parseInt(document.getElementById('thresholdRange').value);
                const morph = parseInt(document.getElementById('morphRange').value);

                const canvas = document.getElementById('finalCanvas');
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');

                // 1. Draw Background
                const bgC = document.createElement('canvas');
                bgC.width = canvas.width; bgC.height = canvas.height;
                bgC.getContext('2d').putImageData(backgroundFrameData, 0, 0);
                ctx.drawImage(bgC, 0, 0);

                // 2. Process all frames
                let validFrames = 0;

                // We perform this synchronously for now as it's fast enough on downsampled ROI
                frameDataList.forEach((item, idx) => {
                    const res = processFrame(item.data, backgroundFrameData, threshold, morph);
                    if (res.found) {
                        validFrames++;
                        const ratio = idx / (frameDataList.length);

                        const scale = res.scale;
                        const ox = res.roiOffset ? res.roiOffset.x : 0;
                        const oy = res.roiOffset ? res.roiOffset.y : 0;

                        const toOrig = (p) => ({
                            x: (p.x * scale) + (ox * scale),
                            y: (p.y * scale) + (oy * scale)
                        });

                        if (res.endpoints.length === 2) {
                            const p1 = toOrig(res.endpoints[0]);
                            const p2 = toOrig(res.endpoints[1]);

                            ctx.beginPath();
                            ctx.strokeStyle = `hsla(${ratio * 300}, 100%, 60%, 0.8)`;
                            ctx.lineWidth = 3;
                            ctx.lineCap = 'round';
                            ctx.moveTo(p1.x, p1.y);
                            ctx.lineTo(p2.x, p2.y);
                            ctx.stroke();

                            ctx.fillStyle = 'white';
                            for (let p of [p1, p2]) {
                                ctx.beginPath();
                                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                    }
                });

                hideLoading();

                if (validFrames === 0) {
                    alert("Í∞êÏßÄÎêú Í∞ùÏ≤¥Í∞Ä ÏóÜÏäµÎãàÎã§. ThresholdÎ•º ÎÇÆÏ∂îÍ±∞ÎÇò ROIÎ•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.");
                }

                // Switch UI
                document.getElementById('step2-content').style.display = 'none';
                document.getElementById('step3-content').style.display = 'block';
                document.getElementById('step2-dot').classList.remove('active');
                document.getElementById('step3-dot').classList.add('active');
            }, 100);
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'analysis_overlay.png';
            link.href = document.getElementById('finalCanvas').toDataURL();
            link.click();
        }

        function showLoading(msg) {
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('loadingText').textContent = msg;
        }
        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }
        function updateProgress(p) {
            document.getElementById('progressFill').style.width = p + '%';
            document.getElementById('progressText').textContent = Math.round(p) + '%';
        }

    </script>
</body>

</html>