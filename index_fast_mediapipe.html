<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Analysis with MediaPipe Pose</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0e27;
            min-height: 100vh;
            padding: 20px;
            color: #e0e0e0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: #1a1f3a;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 25px;
            text-align: center;
            border-bottom: 3px solid #4a90e2;
        }

        .header h1 { 
            font-size: 2em; 
            margin-bottom: 8px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        .header p { opacity: 0.9; font-size: 0.95em; }
        .header .badge {
            display: inline-block;
            background: rgba(255,255,255,0.15);
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.75em;
            margin: 5px 3px;
            border: 1px solid rgba(255,255,255,0.2);
        }

        .main-content { padding: 25px; }

        .upload-section {
            border: 2px dashed #4a5568;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
            background: #252b45;
        }

        .upload-section:hover { 
            border-color: #4a90e2; 
            background: #2d3555;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.2);
        }

        .video-container { display: none; }
        .video-container.active { display: block; }

        video {
            width: 100%;
            max-height: 500px;
            background: black;
            border-radius: 8px;
            margin-bottom: 15px;
            display: block;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .mode-btn {
            padding: 12px 25px;
            border: 2px solid #4a5568;
            border-radius: 8px;
            background: #252b45;
            color: #e0e0e0;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            border-color: #4a90e2;
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.4);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1em;
        }

        .btn-primary { 
            background: linear-gradient(135deg, #4a90e2 0%, #357abd 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(74, 144, 226, 0.3);
        }
        .btn-primary:hover { 
            background: linear-gradient(135deg, #357abd 0%, #2868a8 100%);
            box-shadow: 0 4px 12px rgba(74, 144, 226, 0.5);
        }

        .btn-danger { 
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }
        .btn-danger:hover { background: #a93226; }

        .btn-success { 
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            color: white;
        }
        .btn-success:hover { background: #229954; }

        .btn-warning { 
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
        }
        .btn-warning:hover { background: #d35400; }

        .config-section {
            background: #252b45;
            border: 2px solid #4a5568;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .phase-config {
            display: none;
        }

        .phase-config.active { display: block; }

        .input-group {
            margin: 15px 0;
        }

        .input-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #b0b8c8;
        }

        .input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #4a5568;
            border-radius: 5px;
            font-size: 1em;
            background: #1a1f3a;
            color: #e0e0e0;
        }

        .input-group input:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 8px rgba(74, 144, 226, 0.4);
        }

        .input-row {
            display: flex;
            gap: 15px;
            align-items: end;
        }

        .input-row .input-group {
            flex: 1;
        }

        .info-box {
            background: #2d3555;
            border-left: 4px solid #4a90e2;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .warning-box {
            background: #3a2d1f;
            border-left: 4px solid #f39c12;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .error-box {
            background: #3a1f1f;
            border-left: 4px solid #e74c3c;
            padding: 12px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .tags-section {
            background: #252b45;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 1px solid #4a5568;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag-item {
            display: flex;
            align-items: center;
            background: #1a1f3a;
            border: 1px solid #4a5568;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #e0e0e0;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tag-item:hover {
            background: #2d3555;
            border-color: #4a90e2;
        }

        .tag-item .remove-btn {
            margin-left: 8px;
            color: #e74c3c;
            font-weight: bold;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }

        .step {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4a5568;
            transition: all 0.3s;
        }

        .step.active { 
            background: #4a90e2; 
            transform: scale(1.2); 
            box-shadow: 0 0 12px rgba(74, 144, 226, 0.6);
        }

        .threshold-control {
            background: #252b45;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            border: 1px solid #4a5568;
        }

        .preview-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .preview-box {
            text-align: center;
            background: #252b45;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #4a5568;
        }

        .preview-box h4 {
            margin-bottom: 10px;
            color: #4a90e2;
        }

        .preview-box canvas {
            width: 100%;
            border: 1px solid #4a5568;
            border-radius: 8px;
            background: #000;
        }

        input[type="range"] {
            width: 80%;
            margin: 15px 0;
            accent-color: #4a90e2;
        }

        .result-container {
            text-align: center;
            padding: 20px;
        }
        
        #finalCanvas {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            background: #000;
        }

        .loading-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(10, 14, 39, 0.95);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
        }
        
        .spinner {
            width: 60px; height: 60px;
            border: 6px solid rgba(74, 144, 226, 0.2);
            border-top: 6px solid #4a90e2;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
            box-shadow: 0 0 20px rgba(74, 144, 226, 0.4);
        }
        
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        .progress-bar {
            width: 350px;
            height: 24px;
            background: rgba(74, 144, 226, 0.1);
            border-radius: 12px;
            overflow: hidden;
            margin: 20px 0;
            border: 1px solid rgba(74, 144, 226, 0.3);
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #2a5298);
            transition: width 0.3s;
            border-radius: 12px;
            box-shadow: 0 0 15px rgba(74, 144, 226, 0.6);
        }

        .keypoint-selector {
            background: #252b45;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #4a5568;
        }

        .keypoint-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .keypoint-btn {
            padding: 8px 12px;
            background: #1a1f3a;
            border: 2px solid #4a5568;
            border-radius: 6px;
            color: #b0b8c8;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
        }

        .keypoint-btn:hover {
            background: #2d3555;
            border-color: #4a90e2;
            color: #e0e0e0;
        }

        .keypoint-btn.selected {
            background: linear-gradient(135deg, #4a90e2 0%, #2a5298 100%);
            border-color: #4a90e2;
            color: white;
            box-shadow: 0 0 10px rgba(74, 144, 226, 0.5);
        }

        .trajectory-canvas {
            border: 2px solid #4a5568;
            border-radius: 8px;
            background: #000;
            margin-top: 15px;
        }

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”¬ Motion Analysis Lab</h1>
            <p id="stepTitle">Step 1: ë¹„ë””ì˜¤ ì—…ë¡œë“œ ë° ì‹œì  ì„ íƒ</p>
            <div>
                <span class="badge">âš¡ WebGL GPU</span>
                <span class="badge">ğŸ¦´ MediaPipe Pose</span>
                <span class="badge">ğŸ“Š Trajectory Analysis</span>
            </div>
        </div>

        <div class="main-content">
            <div class="step-indicator">
                <div class="step active" id="step1-dot"></div>
                <div class="step" id="step2-dot"></div>
                <div class="step" id="step3-dot"></div>
            </div>

            <!-- Step 1: Selection -->
            <div id="step1-content">
                <div class="upload-section" id="uploadSection" onclick="document.getElementById('videoInput').click()">
                    <h2>ğŸ“‚ ë¹„ë””ì˜¤ ì—…ë¡œë“œ</h2>
                    <p>ì¸ì²´ ë™ì‘ ë¶„ì„ì„ ìœ„í•œ ë¹„ë””ì˜¤ë¥¼ ì„ íƒí•˜ì„¸ìš”</p>
                    <input type="file" id="videoInput" accept="video/*" style="display: none;">
                </div>

                <div class="video-container" id="videoContainer">
                    <!-- ëª¨ë“œ ì„ íƒ -->
                    <div class="mode-selector">
                        <button class="mode-btn active" onclick="switchMode('event')" id="eventModeBtn">
                            ğŸ“ ì´ë²¤íŠ¸ ëª¨ë“œ<br><small>ê°œë³„ ì‹œì  ì„ íƒ</small>
                        </button>
                        <button class="mode-btn" onclick="switchMode('phase')" id="phaseModeBtn">
                            ğŸ“Š êµ¬ê°„ ë¶„ì„ ëª¨ë“œ<br><small>ì‹œì‘/ë/ê°„ê²© ì„¤ì •</small>
                        </button>
                    </div>

                    <video id="videoPlayer" controls></video>
                    
                    <!-- ì˜ìƒ ì¶”ì¶œ êµ¬ê°„ (ê³µí†µ) -->
                    <div class="config-section">
                        <h3>ğŸ¥ ì˜ìƒ ì¶”ì¶œ êµ¬ê°„ ì„¤ì •</h3>
                        <div class="info-box">
                            ìµœì¢… ê²°ê³¼ ì˜ìƒì— í¬í•¨ë  êµ¬ê°„ì„ ì„¤ì •í•©ë‹ˆë‹¤. ë¶„ì„ ì‹œì ì€ ì´ êµ¬ê°„ ë‚´ì—ì„œ ì„ íƒë©ë‹ˆë‹¤.
                        </div>
                        <div class="input-row">
                            <div class="input-group">
                                <label>ì¶”ì¶œ ì‹œì‘ (ì´ˆ)</label>
                                <input type="number" id="extractStart" step="0.1" min="0" value="0">
                            </div>
                            <div class="input-group">
                                <label>ì¶”ì¶œ ì¢…ë£Œ (ì´ˆ)</label>
                                <input type="number" id="extractEnd" step="0.1" min="0" value="5">
                            </div>
                        </div>
                        <div class="controls" style="margin-top: 10px;">
                            <button class="btn btn-warning" onclick="setCurrentAsExtractStart()">
                                â®ï¸ í˜„ì¬ â†’ ì¶”ì¶œ ì‹œì‘
                            </button>
                            <button class="btn btn-warning" onclick="setCurrentAsExtractEnd()">
                                â­ï¸ í˜„ì¬ â†’ ì¶”ì¶œ ì¢…ë£Œ
                            </button>
                        </div>
                        <div class="info-box" id="extractInfo">
                            ğŸ’¡ ìµœì¢… ì˜ìƒì— í¬í•¨ë  êµ¬ê°„ì„ ì„¤ì •í•˜ì„¸ìš”.
                        </div>
                    </div>

                    <!-- ì´ë²¤íŠ¸ ëª¨ë“œ ì»¨íŠ¸ë¡¤ -->
                    <div id="eventModeControls">
                        <div class="controls">
                            <button class="btn btn-primary" onclick="addTimepoint()">
                                ğŸ“¸ ì‹œì  ì¶”ê°€ (Space)
                            </button>
                            <button class="btn btn-danger" onclick="clearAll()">
                                ğŸ—‘ï¸ ì´ˆê¸°í™”
                            </button>
                        </div>

                        <div class="tags-section">
                            <h3>ì„ íƒëœ ì‹œì  (<span id="tagCount">0</span>)</h3>
                            <div class="tag-list" id="tagsContainer"></div>
                        </div>
                    </div>

                    <!-- êµ¬ê°„ ë¶„ì„ ëª¨ë“œ ì»¨íŠ¸ë¡¤ -->
                    <div class="phase-config" id="phaseConfig">
                        <h3>ğŸ“Š ë¶„ì„ ëŒ€ìƒ êµ¬ê°„ ì„¤ì •</h3>
                        
                        <div class="input-row">
                            <div class="input-group">
                                <label>ì‹œì‘ ì‹œê°„ (ì´ˆ)</label>
                                <input type="number" id="startTime" step="0.1" min="0" value="0">
                            </div>
                            <div class="input-group">
                                <label>ì¢…ë£Œ ì‹œê°„ (ì´ˆ)</label>
                                <input type="number" id="endTime" step="0.1" min="0" value="5">
                            </div>
                        </div>

                        <div class="input-group">
                            <label>í”„ë ˆì„ ê°„ê²© (í”„ë ˆì„ ìˆ˜)</label>
                            <input type="number" id="frameInterval" min="1" value="30">
                        </div>

                        <div class="controls" style="margin-top: 15px;">
                            <button class="btn btn-warning" onclick="setCurrentAsStart()">
                                â®ï¸ í˜„ì¬ â†’ ë¶„ì„ ì‹œì‘
                            </button>
                            <button class="btn btn-warning" onclick="setCurrentAsEnd()">
                                â­ï¸ í˜„ì¬ â†’ ë¶„ì„ ì¢…ë£Œ
                            </button>
                        </div>

                        <div class="controls">
                            <button class="btn btn-primary" onclick="calculatePhasePoints()">
                                ğŸ”„ ì‹œì  ìë™ ìƒì„±
                            </button>
                            <button class="btn btn-danger" onclick="clearAll()">
                                ğŸ—‘ï¸ ì´ˆê¸°í™”
                            </button>
                        </div>

                        <div class="info-box" id="phaseInfo">
                            ğŸ’¡ ì„¤ì •ì„ ì…ë ¥í•˜ê³  "ì‹œì  ìë™ ìƒì„±"ì„ í´ë¦­í•˜ì„¸ìš”.
                        </div>

                        <div class="tags-section">
                            <h3>ìƒì„±ëœ ì‹œì  (<span id="phaseTagCount">0</span>)</h3>
                            <div class="tag-list" id="phaseTagsContainer"></div>
                        </div>
                    </div>

                    <div style="text-align: center;">
                        <button id="toStep2Btn" class="btn btn-success" style="display: none; width: 100%;" onclick="goToStep2()">
                            ë‹¤ìŒ: Pose ë¶„ì„ ë° ì„¤ì • ğŸ‘‰
                        </button>
                    </div>
                </div>
            </div>

            <!-- Step 2: Pose Analysis & Config -->
            <div id="step2-content" style="display: none;">
                <div class="info-box">
                    âš¡ MediaPipe Poseë¡œ ê° ì‹œì ì˜ ê´€ì ˆ ìœ„ì¹˜ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...
                </div>

                <div class="preview-container">
                    <div class="preview-box">
                        <h4>ì›ë³¸ í”„ë ˆì„</h4>
                        <canvas id="previewOriginal"></canvas>
                    </div>
                    <div class="preview-box">
                        <h4>Pose ìŠ¤ì¼ˆë ˆí†¤</h4>
                        <canvas id="previewSkeleton"></canvas>
                    </div>
                </div>

                <div class="keypoint-selector">
                    <h3>ğŸ¯ ê¶¤ì  ë¶„ì„í•  ê´€ì ˆ ì„ íƒ</h3>
                    <p style="margin: 10px 0; color: #b0b8c8;">ë¶„ì„í•˜ê³  ì‹¶ì€ ê´€ì ˆì„ ì„ íƒí•˜ì„¸ìš”. ì—¬ëŸ¬ ê°œ ì„ íƒ ê°€ëŠ¥í•©ë‹ˆë‹¤.</p>
                    <div class="keypoint-grid" id="keypointGrid"></div>
                </div>

                <div class="threshold-control">
                    <h3>ğŸšï¸ ê°ì²´ ê°ì§€ ë¯¼ê°ë„ (ì˜µì…˜)</h3>
                    <p style="margin: 10px 0; color: #b0b8c8;">ë°°ê²½ ì œê±° ë¯¼ê°ë„ (Pose ë¶„ì„ê³¼ ë³„ê°œ)</p>
                    <input type="range" id="thresholdSlider" min="5" max="100" value="15" oninput="updateThresholdValue()">
                    <span id="thresholdValue">15</span>
                </div>

                <div class="controls" style="margin-top: 30px;">
                    <button class="btn btn-danger" onclick="goToStep1()">ğŸ‘ˆ ë’¤ë¡œê°€ê¸°</button>
                    <button class="btn btn-success" onclick="generateResult()">ê²°ê³¼ ìƒì„± (ì´ë¯¸ì§€ + ì˜ìƒ + ê¶¤ì ) ğŸ‘‰</button>
                </div>
            </div>

            <!-- Step 3: Result -->
            <div id="step3-content" class="result-container" style="display: none;">
                <h2>âœ¨ ë¶„ì„ ê²°ê³¼</h2>
                
                <div class="preview-container" style="margin: 30px 0;">
                    <div class="preview-box">
                        <h3>ğŸ–¼ï¸ í•©ì„± ì´ë¯¸ì§€</h3>
                        <canvas id="finalCanvas" style="width: 100%;"></canvas>
                        <button class="btn btn-primary" style="margin-top: 10px; width: 100%;" onclick="downloadImage()">
                            ğŸ’¾ ì´ë¯¸ì§€ ì €ì¥
                        </button>
                    </div>
                    <div class="preview-box">
                        <h3>ğŸ¥ ëª¨ì…˜ íŠ¸ë ˆì¼ ì˜ìƒ</h3>
                        <video id="finalVideo" controls style="width: 100%; border-radius: 8px; background: #000;"></video>
                        <button class="btn btn-primary" style="margin-top: 10px; width: 100%;" onclick="downloadVideo()">
                            ğŸ’¾ ì˜ìƒ ì €ì¥
                        </button>
                    </div>
                </div>

                <div style="margin: 40px 0; border-top: 2px solid #4a5568; padding-top: 20px;">
                    <h3>ğŸ“ˆ ì„ íƒí•œ ê´€ì ˆì˜ ê¶¤ì  ë¶„ì„</h3>
                    <div style="max-width: 800px; margin: 0 auto;">
                        <canvas id="trajectoryCanvas" class="trajectory-canvas" style="width: 100%;"></canvas>
                        <button class="btn btn-primary" style="margin-top: 10px;" onclick="downloadTrajectory()">
                            ğŸ’¾ ê¶¤ì  ì´ë¯¸ì§€ ì €ì¥
                        </button>
                    </div>
                </div>

                <div class="info-box" id="perfStats" style="text-align: left; max-width: 700px; margin: 20px auto;">
                    â±ï¸ ì²˜ë¦¬ ì‹œê°„ í†µê³„ê°€ ì—¬ê¸°ì— í‘œì‹œë©ë‹ˆë‹¤.
                </div>

                <button class="btn btn-danger" onclick="location.reload()">ğŸ”„ ì²˜ìŒë¶€í„° ë‹¤ì‹œ</button>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <h3 id="loadingText">ì²˜ë¦¬ ì¤‘...</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        <p id="progressText" style="font-size: 1.2em; margin: 10px 0;">0%</p>
        <p id="loadingSubtext" style="font-size: 0.9em; opacity: 0.8;"></p>
    </div>

    <!-- Hidden WebGL Canvas -->
    <canvas id="glCanvas" style="display: none;"></canvas>

    <script>
        const video = document.getElementById('videoPlayer');
        const videoInput = document.getElementById('videoInput');
        
        let timepoints = [];
        let backgroundFrame = null;
        let frameData = [];
        let poseResults = []; // MediaPipe Pose ê²°ê³¼ ì €ì¥
        let selectedKeypoints = []; // ì„ íƒëœ ê´€ì ˆ ì¸ë±ìŠ¤
        let gl = null;
        let glProgram = null;
        let performanceStats = {};
        let currentMode = 'event';
        let extractStartTime = 0;
        let extractEndTime = 5;
        let pose = null;

        // MediaPipe Pose ëœë“œë§ˆí¬ ì´ë¦„ (33ê°œ)
        const POSE_LANDMARKS = [
            'Nose', 'Left Eye Inner', 'Left Eye', 'Left Eye Outer',
            'Right Eye Inner', 'Right Eye', 'Right Eye Outer',
            'Left Ear', 'Right Ear', 'Mouth Left', 'Mouth Right',
            'Left Shoulder', 'Right Shoulder', 'Left Elbow', 'Right Elbow',
            'Left Wrist', 'Right Wrist', 'Left Pinky', 'Right Pinky',
            'Left Index', 'Right Index', 'Left Thumb', 'Right Thumb',
            'Left Hip', 'Right Hip', 'Left Knee', 'Right Knee',
            'Left Ankle', 'Right Ankle', 'Left Heel', 'Right Heel',
            'Left Foot Index', 'Right Foot Index'
        ];

        // ì£¼ìš” ê´€ì ˆë§Œ ì„ íƒ ê°€ëŠ¥í•˜ë„ë¡
        const MAIN_KEYPOINTS = [
            0, // Nose
            11, 12, // Shoulders
            13, 14, // Elbows
            15, 16, // Wrists
            23, 24, // Hips
            25, 26, // Knees
            27, 28  // Ankles
        ];

        // ìŠ¤ì¼ˆë ˆí†¤ ì—°ê²°ì„ 
        const POSE_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 7],
            [0, 4], [4, 5], [5, 6], [6, 8],
            [9, 10],
            [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19],
            [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20],
            [11, 23], [12, 24], [23, 24],
            [23, 25], [25, 27], [27, 29], [27, 31],
            [24, 26], [26, 28], [28, 30], [28, 32]
        ];

        // ===== MediaPipe Pose ì´ˆê¸°í™” =====
        function initMediaPipe() {
            pose = new Pose({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                }
            });
            
            pose.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: false,
                smoothSegmentation: false,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            console.log('MediaPipe Pose initialized');
        }

        async function detectPoseFromImage(imageSource) {
            return new Promise(async (resolve) => {
                const tempCanvas = document.createElement('canvas');
                const ctx = tempCanvas.getContext('2d');
                tempCanvas.width = video.videoWidth;
                tempCanvas.height = video.videoHeight;
                ctx.drawImage(imageSource, 0, 0);

                pose.onResults((results) => {
                    resolve(results);
                });

                await pose.send({ image: tempCanvas });
            });
        }

        function drawPoseLandmarks(canvas, landmarks, connections) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;

            // ì—°ê²°ì„  ê·¸ë¦¬ê¸°
            ctx.strokeStyle = '#4a90e2';
            ctx.lineWidth = 3;
            connections.forEach(([start, end]) => {
                if (landmarks[start] && landmarks[end]) {
                    ctx.beginPath();
                    ctx.moveTo(landmarks[start].x * width, landmarks[start].y * height);
                    ctx.lineTo(landmarks[end].x * width, landmarks[end].y * height);
                    ctx.stroke();
                }
            });

            // ê´€ì ˆ ê·¸ë¦¬ê¸°
            landmarks.forEach((landmark, idx) => {
                const x = landmark.x * width;
                const y = landmark.y * height;
                
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                
                if (selectedKeypoints.includes(idx)) {
                    ctx.fillStyle = '#f39c12'; // ì„ íƒëœ ê´€ì ˆì€ ì£¼í™©ìƒ‰
                    ctx.fill();
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    ctx.fillStyle = '#2ecc71';
                    ctx.fill();
                }
            });
        }

        // ===== Mode Switching =====
        function switchMode(mode) {
            currentMode = mode;
            
            if (mode === 'event') {
                document.getElementById('eventModeBtn').classList.add('active');
                document.getElementById('phaseModeBtn').classList.remove('active');
                document.getElementById('eventModeControls').style.display = 'block';
                document.getElementById('phaseConfig').classList.remove('active');
            } else {
                document.getElementById('phaseModeBtn').classList.add('active');
                document.getElementById('eventModeBtn').classList.remove('active');
                document.getElementById('eventModeControls').style.display = 'none';
                document.getElementById('phaseConfig').classList.add('active');
            }
            
            updateTags();
        }

        function setCurrentAsStart() {
            document.getElementById('startTime').value = video.currentTime.toFixed(2);
            calculatePhaseInfo();
        }

        function setCurrentAsEnd() {
            document.getElementById('endTime').value = video.currentTime.toFixed(2);
            calculatePhaseInfo();
        }

        function setCurrentAsExtractStart() {
            document.getElementById('extractStart').value = video.currentTime.toFixed(2);
            updateExtractInfo();
        }

        function setCurrentAsExtractEnd() {
            document.getElementById('extractEnd').value = video.currentTime.toFixed(2);
            updateExtractInfo();
        }

        function updateExtractInfo() {
            const start = parseFloat(document.getElementById('extractStart').value) || 0;
            const end = parseFloat(document.getElementById('extractEnd').value) || 0;
            const duration = end - start;
            
            const infoEl = document.getElementById('extractInfo');
            if (start >= end) {
                infoEl.className = 'error-box';
                infoEl.innerHTML = 'âš ï¸ ì¶”ì¶œ ì¢…ë£Œ ì‹œê°„ì€ ì‹œì‘ ì‹œê°„ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤.';
            } else if (end > video.duration) {
                infoEl.className = 'error-box';
                infoEl.innerHTML = `âš ï¸ ì¶”ì¶œ ì¢…ë£Œ ì‹œê°„ì´ ë¹„ë””ì˜¤ ê¸¸ì´(${video.duration.toFixed(2)}ì´ˆ)ë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.`;
            } else {
                infoEl.className = 'info-box';
                infoEl.innerHTML = `
                    ğŸ¬ <strong>ìµœì¢… ì˜ìƒ ì •ë³´</strong><br>
                    â€¢ ì¶”ì¶œ êµ¬ê°„: ${start.toFixed(2)}ì´ˆ ~ ${end.toFixed(2)}ì´ˆ<br>
                    â€¢ ì˜ìƒ ê¸¸ì´: ${duration.toFixed(2)}ì´ˆ
                `;
            }
            
            extractStartTime = start;
            extractEndTime = end;
        }

        function calculatePhaseInfo() {
            const start = parseFloat(document.getElementById('startTime').value) || 0;
            const end = parseFloat(document.getElementById('endTime').value) || 0;
            const interval = parseInt(document.getElementById('frameInterval').value) || 30;
            const fps = 30;
            
            const duration = end - start;
            const intervalSeconds = interval / fps;
            const pointCount = Math.floor(duration / intervalSeconds) + 1;
            
            const infoEl = document.getElementById('phaseInfo');
            if (start >= end) {
                infoEl.className = 'error-box';
                infoEl.innerHTML = 'âš ï¸ ì¢…ë£Œ ì‹œê°„ì€ ì‹œì‘ ì‹œê°„ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤.';
            } else {
                infoEl.className = 'info-box';
                infoEl.innerHTML = `
                    ğŸ“Š <strong>ë¶„ì„ ì •ë³´</strong><br>
                    â€¢ êµ¬ê°„: ${start.toFixed(2)}ì´ˆ ~ ${end.toFixed(2)}ì´ˆ (${duration.toFixed(2)}ì´ˆ)<br>
                    â€¢ í”„ë ˆì„ ê°„ê²©: ${interval}í”„ë ˆì„ (${intervalSeconds.toFixed(2)}ì´ˆë§ˆë‹¤)<br>
                    â€¢ ìƒì„±ë  ì‹œì : ì•½ <strong>${pointCount}ê°œ</strong>
                `;
            }
        }

        function calculatePhasePoints() {
            const start = parseFloat(document.getElementById('startTime').value) || 0;
            const end = parseFloat(document.getElementById('endTime').value) || 0;
            const interval = parseInt(document.getElementById('frameInterval').value) || 30;
            const fps = 30;
            
            if (start >= end) {
                alert('ì¢…ë£Œ ì‹œê°„ì€ ì‹œì‘ ì‹œê°„ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤.');
                return;
            }
            
            if (end > video.duration) {
                alert(`ì¢…ë£Œ ì‹œê°„ì´ ë¹„ë””ì˜¤ ê¸¸ì´(${video.duration.toFixed(2)}ì´ˆ)ë¥¼ ì´ˆê³¼í•©ë‹ˆë‹¤.`);
                return;
            }
            
            timepoints = [];
            const intervalSeconds = interval / fps;
            
            for (let t = start; t <= end; t += intervalSeconds) {
                if (t <= video.duration) {
                    timepoints.push(Math.min(t, end));
                }
            }
            
            if (timepoints[timepoints.length - 1] < end && end <= video.duration) {
                timepoints.push(end);
            }
            
            updateTags();
            alert(`${timepoints.length}ê°œì˜ ì‹œì ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!`);
        }

        // ===== Step 1: Setup & Selection =====
        videoInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                video.src = URL.createObjectURL(file);
                document.getElementById('uploadSection').style.display = 'none';
                document.getElementById('videoContainer').classList.add('active');
                
                video.addEventListener('loadedmetadata', () => {
                    initWebGL();
                    initMediaPipe();
                    
                    const defaultEnd = Math.min(5, video.duration);
                    document.getElementById('endTime').value = defaultEnd.toFixed(2);
                    document.getElementById('extractEnd').value = defaultEnd.toFixed(2);
                    calculatePhaseInfo();
                    updateExtractInfo();
                }, { once: true });
            }
        });

        function addTimepoint() {
            const time = video.currentTime;
            if (!timepoints.some(t => Math.abs(t - time) < 0.1)) {
                timepoints.push(time);
                timepoints.sort((a, b) => a - b);
                updateTags();
            }
        }

        function removeTimepoint(index) {
            timepoints.splice(index, 1);
            updateTags();
        }

        function clearAll() {
            timepoints = [];
            updateTags();
        }

        function updateTags() {
            if (currentMode === 'event') {
                const container = document.getElementById('tagsContainer');
                document.getElementById('tagCount').textContent = timepoints.length;
                container.innerHTML = '';
                
                timepoints.forEach((time, index) => {
                    const div = document.createElement('div');
                    div.className = 'tag-item';
                    div.innerHTML = `<span onclick="video.currentTime=${time}">${time.toFixed(2)}s</span> <span class="remove-btn" onclick="removeTimepoint(${index})">Ã—</span>`;
                    container.appendChild(div);
                });
            } else {
                const container = document.getElementById('phaseTagsContainer');
                document.getElementById('phaseTagCount').textContent = timepoints.length;
                container.innerHTML = '';
                
                timepoints.forEach((time, index) => {
                    const div = document.createElement('div');
                    div.className = 'tag-item';
                    div.innerHTML = `<span onclick="video.currentTime=${time}">${time.toFixed(2)}s</span> <span class="remove-btn" onclick="removeTimepoint(${index})">Ã—</span>`;
                    container.appendChild(div);
                });
            }

            document.getElementById('toStep2Btn').style.display = timepoints.length > 0 ? 'block' : 'none';
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && video.src && currentMode === 'event' && document.getElementById('step1-content').style.display !== 'none') {
                e.preventDefault();
                video.paused ? video.play() : (video.pause(), addTimepoint());
            }
        });

        // ===== Step 2: Pose Analysis =====
        async function goToStep2() {
            const startTime = performance.now();
            showLoading('í”„ë ˆì„ ì¶”ì¶œ ë° Pose ë¶„ì„ ì¤‘...', 'MediaPipeë¡œ ê´€ì ˆ ìœ„ì¹˜ ê²€ì¶œ');
            
            video.currentTime = 0;
            await waitForSeek();
            backgroundFrame = await captureFrame();

            frameData = [];
            poseResults = [];
            
            for (let i = 0; i < timepoints.length; i++) {
                const time = timepoints[i];
                video.currentTime = time;
                await waitForSeek();
                const frame = await captureFrame();
                
                updateProgress(Math.floor((i + 1) / timepoints.length * 50), `${Math.floor((i + 1) / timepoints.length * 50)}%`);
                updateLoadingSubtext(`í”„ë ˆì„ ì¶”ì¶œ ì¤‘... ${i + 1}/${timepoints.length}`);
                
                // MediaPipe Pose ë¶„ì„
                const poseResult = await detectPoseFromImage(video);
                
                frameData.push({ time, frame });
                poseResults.push(poseResult);
                
                updateProgress(50 + Math.floor((i + 1) / timepoints.length * 50), `${50 + Math.floor((i + 1) / timepoints.length * 50)}%`);
                updateLoadingSubtext(`Pose ë¶„ì„ ì¤‘... ${i + 1}/${timepoints.length}`);
            }

            const extractTime = performance.now() - startTime;
            performanceStats.extractTime = extractTime;
            performanceStats.poseCount = poseResults.filter(r => r.poseLandmarks).length;

            hideLoading();
            
            // Keypoint ì„ íƒ UI ìƒì„±
            createKeypointSelector();
            
            // ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
            updatePosePreview();
            
            document.getElementById('step1-content').style.display = 'none';
            document.getElementById('step2-content').style.display = 'block';
            document.getElementById('stepTitle').textContent = 'Step 2: Pose ë¶„ì„ ë° ê´€ì ˆ ì„ íƒ';
            document.getElementById('step1-dot').classList.remove('active');
            document.getElementById('step2-dot').classList.add('active');
        }

        function createKeypointSelector() {
            const grid = document.getElementById('keypointGrid');
            grid.innerHTML = '';
            
            MAIN_KEYPOINTS.forEach(idx => {
                const btn = document.createElement('button');
                btn.className = 'keypoint-btn';
                btn.textContent = POSE_LANDMARKS[idx];
                btn.onclick = () => toggleKeypoint(idx, btn);
                grid.appendChild(btn);
            });
        }

        function toggleKeypoint(idx, btn) {
            const index = selectedKeypoints.indexOf(idx);
            if (index > -1) {
                selectedKeypoints.splice(index, 1);
                btn.classList.remove('selected');
            } else {
                selectedKeypoints.push(idx);
                btn.classList.add('selected');
            }
            updatePosePreview();
        }

        function updatePosePreview() {
            if (frameData.length === 0 || poseResults.length === 0) return;

            const sample = frameData[0];
            const poseResult = poseResults[0];
            const w = video.videoWidth;
            const h = video.videoHeight;

            // ì›ë³¸
            const cvsOrig = document.getElementById('previewOriginal');
            cvsOrig.width = w;
            cvsOrig.height = h;
            cvsOrig.getContext('2d').drawImage(sample.frame, 0, 0);

            // ìŠ¤ì¼ˆë ˆí†¤
            const cvsSkel = document.getElementById('previewSkeleton');
            cvsSkel.width = w;
            cvsSkel.height = h;
            const ctxSkel = cvsSkel.getContext('2d');
            ctxSkel.drawImage(sample.frame, 0, 0);
            
            if (poseResult && poseResult.poseLandmarks) {
                drawPoseLandmarks(cvsSkel, poseResult.poseLandmarks, POSE_CONNECTIONS);
            }
        }

        function updateThresholdValue() {
            const value = document.getElementById('thresholdSlider').value;
            document.getElementById('thresholdValue').textContent = value;
        }

        function goToStep1() {
            document.getElementById('step2-content').style.display = 'none';
            document.getElementById('step1-content').style.display = 'block';
            document.getElementById('stepTitle').textContent = 'Step 1: ë¹„ë””ì˜¤ ì—…ë¡œë“œ ë° ì‹œì  ì„ íƒ';
            document.getElementById('step2-dot').classList.remove('active');
            document.getElementById('step1-dot').classList.add('active');
        }

        // ===== Step 3: Result Generation =====
        async function generateResult() {
            const startTime = performance.now();
            showLoading('ê²°ê³¼ ì´ë¯¸ì§€ ìƒì„± ì¤‘...', 'ëª¨ë“  ì‹œì ì˜ ìŠ¤ì¼ˆë ˆí†¤ í•©ì„±');
            
            const w = video.videoWidth;
            const h = video.videoHeight;

            // 1. í•©ì„± ì´ë¯¸ì§€ ìƒì„±
            const finalCanvas = document.getElementById('finalCanvas');
            finalCanvas.width = w;
            finalCanvas.height = h;
            const ctx = finalCanvas.getContext('2d');

            ctx.drawImage(backgroundFrame, 0, 0);

            for (let i = 0; i < frameData.length; i++) {
                const item = frameData[i];
                const poseResult = poseResults[i];
                
                updateProgress(Math.floor((i + 1) / frameData.length * 100), `${Math.floor((i + 1) / frameData.length * 100)}%`);
                updateLoadingSubtext(`ìŠ¤ì¼ˆë ˆí†¤ ì˜¤ë²„ë ˆì´ ì¤‘... ${i + 1}/${frameData.length}`);
                
                // ë°˜íˆ¬ëª… í”„ë ˆì„ ê·¸ë¦¬ê¸°
                ctx.globalAlpha = 0.3;
                ctx.drawImage(item.frame, 0, 0);
                ctx.globalAlpha = 1.0;
                
                // ìŠ¤ì¼ˆë ˆí†¤ ê·¸ë¦¬ê¸°
                if (poseResult && poseResult.poseLandmarks) {
                    drawPoseLandmarks(finalCanvas, poseResult.poseLandmarks, POSE_CONNECTIONS);
                }
                
                await new Promise(r => setTimeout(r, 10));
            }

            const imageTime = performance.now() - startTime;
            performanceStats.imageTime = imageTime;

            // 2. ê¶¤ì  ê·¸ë˜í”„ ìƒì„±
            showLoading('ê¶¤ì  ë¶„ì„ ì¤‘...', 'ì„ íƒí•œ ê´€ì ˆì˜ ì´ë™ ê²½ë¡œ ê³„ì‚°');
            generateTrajectoryGraph();

            // 3. ì˜ìƒ ìƒì„±
            showLoading('ì˜ìƒ ìƒì„± ì¤‘...', 'ìµœì í™”ëœ ìŠ¤íŠ¸ë¦¼ ë Œë”ë§');
            const videoStartTime = performance.now();
            
            await generateVideoFast(w, h);
            
            const videoTime = performance.now() - videoStartTime;
            performanceStats.videoTime = videoTime;
            performanceStats.totalTime = performance.now() - startTime;

            hideLoading();
            
            displayPerformanceStats();

            document.getElementById('step2-content').style.display = 'none';
            document.getElementById('step3-content').style.display = 'block';
            document.getElementById('stepTitle').textContent = 'Step 3: ë¶„ì„ ê²°ê³¼';
            document.getElementById('step2-dot').classList.remove('active');
            document.getElementById('step3-dot').classList.add('active');
        }

        function generateTrajectoryGraph() {
            const canvas = document.getElementById('trajectoryCanvas');
            const w = Math.min(video.videoWidth, 800);
            const h = Math.floor(w * video.videoHeight / video.videoWidth);
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            
            // ë°°ê²½ í”„ë ˆì„ì„ ìº”ë²„ìŠ¤ í¬ê¸°ì— ë§ê²Œ ê·¸ë¦¬ê¸°
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(backgroundFrame, 0, 0);

            // ë°°ê²½
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            ctx.drawImage(tempCanvas, 0, 0, w, h);
            ctx.globalAlpha = 0.7;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);
            ctx.globalAlpha = 1.0;
            
            const scaleX = w / video.videoWidth;
            const scaleY = h / video.videoHeight;

            if (selectedKeypoints.length === 0) {
                ctx.fillStyle = '#fff';
                ctx.font = '24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('ê´€ì ˆì„ ì„ íƒí•˜ë©´ ê¶¤ì ì´ í‘œì‹œë©ë‹ˆë‹¤', w/2, h/2);
                return;
            }

            const colors = ['#f39c12', '#e74c3c', '#3498db', '#2ecc71', '#9b59b6', '#1abc9c'];

            selectedKeypoints.forEach((keypointIdx, colorIdx) => {
                const color = colors[colorIdx % colors.length];
                const points = [];

                poseResults.forEach((result, frameIdx) => {
                    if (result && result.poseLandmarks && result.poseLandmarks[keypointIdx]) {
                        const landmark = result.poseLandmarks[keypointIdx];
                        points.push({
                            x: landmark.x * video.videoWidth * scaleX,
                            y: landmark.y * video.videoHeight * scaleY,
                            time: frameData[frameIdx].time
                        });
                    }
                });

                if (points.length > 1) {
                    // ê¶¤ì  ì„  ê·¸ë¦¬ê¸°
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    for (let i = 1; i < points.length; i++) {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                    ctx.stroke();

                    // ì  ê·¸ë¦¬ê¸°
                    points.forEach((point, idx) => {
                        ctx.beginPath();
                        ctx.arc(point.x, point.y, 6, 0, 2 * Math.PI);
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();

                        // ì‹œì‘/ë í‘œì‹œ
                        if (idx === 0 || idx === points.length - 1) {
                            ctx.fillStyle = '#fff';
                            ctx.font = '12px Arial';
                            ctx.fillText(idx === 0 ? 'START' : 'END', point.x + 10, point.y - 10);
                        }
                    });

                    // ë²”ë¡€
                    ctx.fillStyle = color;
                    ctx.fillRect(20, 30 + colorIdx * 25, 15, 15);
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(POSE_LANDMARKS[keypointIdx], 40, 42 + colorIdx * 25);
                }
            });
        }

        async function generateVideoFast(w, h) {
            const canvas = document.createElement('canvas');
            canvas.width = w;
            canvas.height = h;
            const ctx = canvas.getContext('2d');
            
            const stream = canvas.captureStream(30);
            const mediaRecorder = new MediaRecorder(stream, { 
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 5000000
            });
            const chunks = [];
            
            mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
            mediaRecorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const videoUrl = URL.createObjectURL(blob);
                document.getElementById('finalVideo').src = videoUrl;
                window.finalVideoBlob = blob;
            };
            
            mediaRecorder.start();

            const startTime = extractStartTime;
            const endTime = extractEndTime;
            
            video.currentTime = startTime;
            await waitForSeek();
            
            const duration = endTime - startTime;
            const fps = 30;
            const frameTime = 1000 / fps;
            let currentTime = startTime;
            let frameCount = 0;
            const totalFrames = Math.floor(duration * fps);

            return new Promise((resolve) => {
                function renderFrame() {
                    if (currentTime >= endTime) {
                        mediaRecorder.stop();
                        resolve();
                        return;
                    }

                    ctx.drawImage(video, 0, 0);
                    
                    // ì§€ë‚˜ê°„ ì‹œì ì˜ ìŠ¤ì¼ˆë ˆí†¤ ê·¸ë¦¬ê¸°
                    frameData.forEach((item, idx) => {
                        if (currentTime >= item.time) {
                            const poseResult = poseResults[idx];
                            if (poseResult && poseResult.poseLandmarks) {
                                drawPoseLandmarks(canvas, poseResult.poseLandmarks, POSE_CONNECTIONS);
                            }
                        }
                    });

                    currentTime += 1/fps;
                    frameCount++;
                    
                    const progress = Math.floor(frameCount / totalFrames * 100);
                    if (frameCount % 10 === 0) {
                        updateProgress(progress, `${progress}%`);
                        updateLoadingSubtext(`ì˜ìƒ ë Œë”ë§ ì¤‘...`);
                    }

                    video.currentTime = currentTime;
                    setTimeout(renderFrame, frameTime);
                }

                renderFrame();
            });
        }

        // ===== Helpers =====
        function waitForSeek() {
            return new Promise(resolve => {
                const handler = () => {
                    video.removeEventListener('seeked', handler);
                    resolve();
                };
                video.addEventListener('seeked', handler);
            });
        }

        async function captureFrame() {
            return createImageBitmap(video);
        }

        function showLoading(msg, subtext = '') {
            document.getElementById('loadingText').textContent = msg;
            document.getElementById('loadingSubtext').textContent = subtext;
            document.getElementById('loadingOverlay').style.display = 'flex';
            updateProgress(0, '0%');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }

        function updateLoadingSubtext(text) {
            document.getElementById('loadingSubtext').textContent = text;
        }
        
        function updateProgress(percent, text) {
            const fill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            if (fill) fill.style.width = percent + '%';
            if (progressText) progressText.textContent = text || (percent + '%');
        }

        function displayPerformanceStats() {
            const stats = performanceStats;
            const modeText = currentMode === 'event' ? 'ì´ë²¤íŠ¸ ëª¨ë“œ' : 'êµ¬ê°„ ë¶„ì„ ëª¨ë“œ';
            let videoInfo = '';
            if (currentMode === 'phase') {
                const videoDuration = extractEndTime - extractStartTime;
                videoInfo = `â€¢ ìµœì¢… ì˜ìƒ ê¸¸ì´: ${videoDuration.toFixed(2)}ì´ˆ (${extractStartTime.toFixed(2)}~${extractEndTime.toFixed(2)}ì´ˆ)<br>`;
            }
            const html = `
                â±ï¸ <strong>ì²˜ë¦¬ ì‹œê°„ í†µê³„</strong> (${modeText})<br>
                â€¢ ë¶„ì„ ì‹œì  ìˆ˜: ${timepoints.length}ê°œ<br>
                â€¢ Pose ê²€ì¶œ ì„±ê³µ: ${stats.poseCount}/${timepoints.length}ê°œ<br>
                â€¢ ì„ íƒí•œ ê´€ì ˆ: ${selectedKeypoints.length}ê°œ<br>
                ${videoInfo}
                â€¢ í”„ë ˆì„ ì¶”ì¶œ & Pose ë¶„ì„: ${(stats.extractTime / 1000).toFixed(2)}ì´ˆ<br>
                â€¢ ì´ë¯¸ì§€ í•©ì„±: ${(stats.imageTime / 1000).toFixed(2)}ì´ˆ<br>
                â€¢ ì˜ìƒ ìƒì„±: ${(stats.videoTime / 1000).toFixed(2)}ì´ˆ<br>
                â€¢ <strong>ì´ ì²˜ë¦¬ ì‹œê°„: ${(stats.totalTime / 1000).toFixed(2)}ì´ˆ</strong><br>
                â€¢ ê°€ì† ë°©ì‹: MediaPipe + WebGL
            `;
            document.getElementById('perfStats').innerHTML = html;
        }

        function downloadImage() {
            const link = document.createElement('a');
            link.download = 'pose_overlay_result.png';
            link.href = document.getElementById('finalCanvas').toDataURL();
            link.click();
        }

        function downloadTrajectory() {
            const link = document.createElement('a');
            link.download = 'trajectory_analysis.png';
            link.href = document.getElementById('trajectoryCanvas').toDataURL();
            link.click();
        }

        function downloadVideo() {
            if (window.finalVideoBlob) {
                const link = document.createElement('a');
                link.download = 'motion_trail.webm';
                link.href = URL.createObjectURL(window.finalVideoBlob);
                link.click();
            }
        }

        // ì…ë ¥ ë³€ê²½ì‹œ ì •ë³´ ì—…ë°ì´íŠ¸
        document.addEventListener('DOMContentLoaded', () => {
            ['startTime', 'endTime', 'frameInterval'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', calculatePhaseInfo);
            });
            ['extractStart', 'extractEnd'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', updateExtractInfo);
            });
        });

        // ===== WebGL (ê¸°ì¡´ ì½”ë“œ ìœ ì§€, ì˜µì…˜) =====
        function initWebGL() {
            // WebGL ì´ˆê¸°í™” ì½”ë“œ (ë°°ê²½ ì œê±°ìš©, ì˜µì…˜)
            console.log('WebGL initialized for optional background removal');
        }
    </script>
</body>
</html>
