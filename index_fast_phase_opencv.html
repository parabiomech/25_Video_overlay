<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Overlay Editor (Phase + OpenCV)</title>
    <script src="https://docs.opencv.org/4.8.0/opencv.js" async onload="onOpenCvReady()"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #00b4db 0%, #0083b0 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .header p {
            opacity: 0.9;
            font-size: 0.9em;
        }

        .header .badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            margin: 5px 3px;
        }

        .main-content {
            padding: 20px;
        }

        .upload-section {
            border: 2px dashed #bdc3c7;
            border-radius: 10px;
            padding: 40px;
            text-align: center;
            margin-bottom: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-section:hover {
            border-color: #00b4db;
            background: #e3f2fd;
        }

        .video-container {
            display: none;
            margin-bottom: 20px;
            text-align: center;
        }

        .video-container.active {
            display: block;
        }

        /* Video Wrapper: Shrink to fit video content */
        .video-wrapper {
            position: relative;
            display: inline-block;
            width: auto;
            max-width: 100%;
            background: black;
            border-radius: 8px;
            overflow: hidden;
            line-height: 0;
            margin-bottom: 15px;
        }

        video {
            max-width: 100%;
            max-height: 60vh;
            display: block;
        }

        #roiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: auto;
            cursor: crosshair;
            z-index: 10;
        }

        #roiInfo {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 0.8em;
            pointer-events: none;
            display: none;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .mode-btn {
            padding: 12px 25px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #00b4db 0%, #0083b0 100%);
            color: white;
            border-color: #00b4db;
            box-shadow: 0 4px 8px rgba(0, 180, 219, 0.3);
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 1em;
        }

        .btn-primary {
            background: #00b4db;
            color: white;
        }

        .btn-primary:hover {
            background: #0083b0;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn-success:hover {
            background: #27ae60;
        }

        .btn-warning {
            background: #f39c12;
            color: white;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .phase-config {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
            text-align: left;
        }

        .phase-config.active {
            display: block;
        }

        .input-group {
            margin: 15px 0;
        }

        .input-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 5px;
            color: #2c3e50;
        }

        .input-group input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
        }

        .input-row {
            display: flex;
            gap: 15px;
            align-items: end;
        }

        .input-row .input-group {
            flex: 1;
        }

        .phase-info,
        .extract-info {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-size: 0.9em;
        }

        .extract-info {
            background: #e3f2fd;
            border-color: #00b4db;
        }

        .tags-section {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: left;
        }

        .tag-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .tag-item {
            display: flex;
            align-items: center;
            background: white;
            border: 1px solid #bdc3c7;
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.9em;
            color: #2c3e50;
            cursor: pointer;
        }

        .step-indicator {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            gap: 10px;
        }

        .step {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #bdc3c7;
            transition: all 0.3s;
        }

        .step.active {
            background: #00b4db;
            transform: scale(1.2);
        }

        .config-panel {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .config-group {
            margin-bottom: 15px;
        }

        .config-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .config-group input[type="range"] {
            width: 100%;
        }

        .preview-container {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .preview-box {
            flex: 1;
            min-width: 300px;
            text-align: center;
        }

        .preview-box canvas {
            width: 100%;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #000;
        }

        .result-container {
            text-align: center;
            padding: 20px;
        }

        #finalCanvas {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 1000;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #00b4db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .progress-bar {
            width: 300px;
            height: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00b4db, #0083b0);
            transition: width 0.3s;
            border-radius: 10px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ Motion Overlay Editor</h1>
            <p id="stepTitle">Step 1: Ïò§Î≤ÑÎ†àÏù¥Ìï† ÏãúÏ†ê Î∞è Íµ¨Í∞Ñ Î∂ÑÏÑù</p>
            <div>
                <span class="badge">‚ö° Phase Analysis</span>
                <span class="badge" id="opencvStatus">‚è≥ Loading OpenCV...</span>
            </div>
        </div>

        <div class="main-content">
            <div class="step-indicator">
                <div class="step active" id="step1-dot"></div>
                <div class="step" id="step2-dot"></div>
                <div class="step" id="step3-dot"></div>
            </div>

            <!-- Step 1: Selection -->
            <div id="step1-content">
                <div class="upload-section" id="uploadSection" onclick="document.getElementById('videoInput').click()">
                    <h2>üìÇ ÎπÑÎîîÏò§ Ïó¥Í∏∞</h2>
                    <p>OpenCV Enhanced | ROI, HSV, YCbCr, Phase Mode</p>
                    <input type="file" id="videoInput" accept="video/*" style="display: none;">
                </div>

                <div class="video-container" id="videoContainer">
                    <div class="mode-selector">
                        <button class="mode-btn active" onclick="switchMode('event')" id="eventModeBtn">
                            üìç Ïù¥Î≤§Ìä∏ Î™®Îìú<br><small>Í∞úÎ≥Ñ ÏãúÏ†ê ÏÑ†ÌÉù</small>
                        </button>
                        <button class="mode-btn" onclick="switchMode('phase')" id="phaseModeBtn">
                            üìä Íµ¨Í∞Ñ Î∂ÑÏÑù Î™®Îìú<br><small>ÏûêÎèô ÏãúÏ†ê ÏÉùÏÑ±</small>
                        </button>
                    </div>

                    <div class="video-wrapper">
                        <video id="videoPlayer" playsinline controls></video>
                        <canvas id="roiCanvas"></canvas>
                        <div id="roiInfo">ROI: Ï†ÑÏ≤¥ ÌôîÎ©¥</div>
                    </div>

                    <div class="controls">
                        <button class="btn btn-secondary" onclick="toggleRoiMode()">
                            üìê ROI ÏßÄÏ†ï (ÏºúÍ∏∞/ÎÅÑÍ∏∞)
                        </button>
                    </div>

                    <!-- Event Mode -->
                    <div id="eventModeControls">
                        <div class="controls">
                            <button class="btn btn-primary" onclick="addTimepoint()">
                                üì∏ ÏãúÏ†ê Ï∂îÍ∞Ä (Space)
                            </button>
                            <button class="btn btn-danger" onclick="clearAll()">
                                üóëÔ∏è Ï¥àÍ∏∞Ìôî
                            </button>
                        </div>
                        <div class="tags-section">
                            <h3>ÏÑ†ÌÉùÎêú ÏãúÏ†ê (<span id="tagCount">0</span>)</h3>
                            <div class="tag-list" id="tagsContainer"></div>
                        </div>
                    </div>

                    <!-- Phase Mode -->
                    <div class="phase-config" id="phaseConfig">
                        <h3>üî¨ Í≥ºÌïô Î∂ÑÏÑù ÏÑ§Ï†ï</h3>
                        <div style="background: #e3f2fd; padding:15px; border-radius:8px; margin-bottom:15px;">
                            <h4 style="margin-bottom:10px;">üé• ÏòÅÏÉÅ Ï∂îÏ∂ú Íµ¨Í∞Ñ (Result Length)</h4>
                            <div class="input-row">
                                <div class="input-group">
                                    <label>ÏãúÏûë (Ï¥à)</label>
                                    <input type="number" id="extractStart" step="0.1" value="0">
                                </div>
                                <div class="input-group">
                                    <label>Ï¢ÖÎ£å (Ï¥à)</label>
                                    <input type="number" id="extractEnd" step="0.1" value="5">
                                </div>
                            </div>
                            <div class="controls">
                                <button class="btn btn-warning" onclick="setExtractStart()">‚èÆÔ∏è ÌòÑÏû¨ ‚Üí Ï∂îÏ∂ú ÏãúÏûë</button>
                                <button class="btn btn-warning" onclick="setExtractEnd()">‚è≠Ô∏è ÌòÑÏû¨ ‚Üí Ï∂îÏ∂ú Ï¢ÖÎ£å</button>
                            </div>
                            <div class="extract-info" id="extractInfo"></div>
                        </div>

                        <h4 style="margin:20px 0 10px 0;">üìä Î∂ÑÏÑù ÎåÄÏÉÅ Íµ¨Í∞Ñ (Overlay Frames)</h4>
                        <div class="input-row">
                            <div class="input-group">
                                <label>Î∂ÑÏÑù ÏãúÏûë (Ï¥à)</label>
                                <input type="number" id="startTime" step="0.1" value="0">
                            </div>
                            <div class="input-group">
                                <label>Î∂ÑÏÑù Ï¢ÖÎ£å (Ï¥à)</label>
                                <input type="number" id="endTime" step="0.1" value="5">
                            </div>
                        </div>
                        <div class="input-group">
                            <label>ÌîÑÎ†àÏûÑ Í∞ÑÍ≤© (Step)</label>
                            <input type="number" id="frameInterval" min="1" value="15" placeholder="Ïòà: 15 (ÏïΩ 0.5Ï¥à)">
                        </div>
                        <div class="controls">
                            <button class="btn btn-warning" onclick="setPhaseStart()">‚èÆÔ∏è ÌòÑÏû¨ ‚Üí Î∂ÑÏÑù ÏãúÏûë</button>
                            <button class="btn btn-warning" onclick="setPhaseEnd()">‚è≠Ô∏è ÌòÑÏû¨ ‚Üí Î∂ÑÏÑù Ï¢ÖÎ£å</button>
                        </div>
                        <div class="controls">
                            <button class="btn btn-primary" onclick="generatePhasePoints()">üîÑ ÏãúÏ†ê ÏûêÎèô ÏÉùÏÑ±</button>
                            <button class="btn btn-danger" onclick="clearAll()">üóëÔ∏è Ï¥àÍ∏∞Ìôî</button>
                        </div>
                        <div class="phase-info" id="phaseInfo"></div>
                        <div class="tags-section">
                            <h3>ÏÉùÏÑ±Îêú ÏãúÏ†ê (<span id="phaseTagCount">0</span>)</h3>
                            <div class="tag-list" id="phaseTagsContainer"></div>
                        </div>
                    </div>

                    <div style="text-align: center; margin-top:20px;">
                        <button id="toStep2Btn" class="btn btn-success" style="display: none; width: 100%;"
                            onclick="goToStep2()">
                            Îã§Ïùå: ÌååÎùºÎØ∏ÌÑ∞ ÏÑ§Ï†ï üëâ
                        </button>
                    </div>
                </div>
            </div>

            <!-- Step 2: Config -->
            <div id="step2-content" style="display: none;">
                <div class="perf-info">
                    üõ†Ô∏è ÏïåÍ≥†Î¶¨Ï¶ò: Downsample ‚Üí ROI ‚Üí YCbCr/HSV Analysis ‚Üí Morphology ‚Üí Skeletonize
                </div>

                <div class="config-panel">
                    <div class="config-group">
                        <label>ÌÉêÏÉâ ÎØºÍ∞êÎèÑ (Threshold): <span id="threshVal">30</span></label>
                        <input type="range" id="thresholdRange" min="5" max="100" value="30" oninput="updatePreview()">
                    </div>
                    <div class="config-group">
                        <label>ÎÖ∏Ïù¥Ï¶à Ï†úÍ±∞ (Morphology): <span id="morphVal">2</span></label>
                        <input type="range" id="morphRange" min="0" max="10" value="2" oninput="updatePreview()">
                    </div>
                </div>

                <div class="preview-container">
                    <div class="preview-box">
                        <h4>ROI ÎØ∏Î¶¨Î≥¥Í∏∞</h4>
                        <canvas id="previewRoi"></canvas>
                    </div>
                    <div class="preview-box">
                        <h4>Ï≤òÎ¶¨ Í≤∞Í≥º (Preview)</h4>
                        <canvas id="previewProc"></canvas>
                    </div>
                </div>

                <div class="controls" style="margin-top: 30px;">
                    <button class="btn btn-danger" onclick="goToStep1()">üëà Îí§Î°úÍ∞ÄÍ∏∞</button>
                    <button class="btn btn-success" onclick="generateResult()">Í≤∞Í≥º ÏÉùÏÑ±ÌïòÍ∏∞ üëâ</button>
                </div>
            </div>

            <!-- Step 3: Result -->
            <div id="step3-content" class="result-container" style="display: none;">
                <h2>‚ú® Í≤∞Í≥º ÌôïÏù∏</h2>

                <div style="margin: 20px 0;">
                    <h3>üñºÔ∏è Ìï©ÏÑ± Í≤∞Í≥º</h3>
                    <canvas id="finalCanvas"></canvas>
                    <button class="btn btn-primary" style="margin-top: 10px;" onclick="downloadImage()">
                        üíæ ÏÇ¨ÏßÑ Ï†ÄÏû•
                    </button>
                </div>

                <button class="btn btn-danger" onclick="location.reload()">üîÑ Ï≤òÏùåÎ∂ÄÌÑ∞ Îã§Ïãú</button>
            </div>
        </div>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner"></div>
        <h3 id="loadingText">Ï≤òÎ¶¨ Ï§ë...</h3>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 0%"></div>
        </div>
        <p id="progressText">0%</p>
    </div>

    <script>
        // --- Global State ---
        const video = document.getElementById('videoPlayer');
        const roiCanvas = document.getElementById('roiCanvas');
        let cvReady = false;

        let timepoints = [];
        let roiRect = null;
        let isRoiMode = false, isSelectingRoi = false;
        let startX, startY;

        let currentMode = 'event';
        let backgroundFrameData = null;
        let frameDataList = [];

        function onOpenCvReady() {
            cvReady = true;
            document.getElementById('opencvStatus').textContent = '‚úÖ OpenCV Ready';
            document.getElementById('opencvStatus').style.background = 'rgba(46, 204, 113, 0.2)';
            document.getElementById('opencvStatus').style.color = '#27ae60';
        }

        // --- Video & UI Event Handlers ---
        document.getElementById('videoInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                video.src = URL.createObjectURL(file);
                document.getElementById('uploadSection').style.display = 'none';
                document.getElementById('videoContainer').classList.add('active');

                video.onloadedmetadata = () => {
                    syncCanvasSize();
                    // Set default end times
                    document.getElementById('extractEnd').value = video.duration.toFixed(2);
                    document.getElementById('endTime').value = video.duration.toFixed(2);
                    updatePhaseInfos();
                };
            }
        });

        window.addEventListener('resize', syncCanvasSize);
        function syncCanvasSize() {
            if (video.videoWidth) {
                roiCanvas.width = video.clientWidth;
                roiCanvas.height = video.clientHeight;
                drawRoiBox();
            }
        }

        function switchMode(mode) {
            currentMode = mode;
            if (mode === 'event') {
                document.getElementById('eventModeBtn').classList.add('active');
                document.getElementById('phaseModeBtn').classList.remove('active');
                document.getElementById('eventModeControls').style.display = 'block';
                document.getElementById('phaseConfig').classList.remove('active');
            } else {
                document.getElementById('phaseModeBtn').classList.add('active');
                document.getElementById('eventModeBtn').classList.remove('active');
                document.getElementById('eventModeControls').style.display = 'none';
                document.getElementById('phaseConfig').classList.add('active');
                updatePhaseInfos();
            }
            updateTags(); // Refresh button visibility
        }

        // --- ROI Logic ---
        function toggleRoiMode() {
            if (!video.src) return;
            isRoiMode = !isRoiMode;
            roiCanvas.style.pointerEvents = isRoiMode ? 'auto' : 'none';
            roiCanvas.style.cursor = isRoiMode ? 'crosshair' : 'default';
            const btn = document.querySelector('.controls .btn-secondary');

            if (isRoiMode) {
                btn.style.background = '#e67e22';
                btn.textContent = 'üìê ROI ÏôÑÎ£å';
                document.getElementById('roiInfo').style.display = 'block';
                syncCanvasSize();
            } else {
                btn.style.background = '#95a5a6';
                btn.textContent = 'üìê ROI ÏßÄÏ†ï (ÏºúÍ∏∞/ÎÅÑÍ∏∞)';
            }
        }

        roiCanvas.addEventListener('mousedown', e => {
            if (!isRoiMode) return;
            isSelectingRoi = true;
            const rect = roiCanvas.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;
        });

        roiCanvas.addEventListener('mousemove', e => {
            if (!isSelectingRoi || !isRoiMode) return;
            const rect = roiCanvas.getBoundingClientRect();
            const currX = e.clientX - rect.left;
            const currY = e.clientY - rect.top;

            const ctx = roiCanvas.getContext('2d');
            ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);
            ctx.strokeStyle = '#e74c3c';
            ctx.lineWidth = 2;
            ctx.strokeRect(startX, startY, currX - startX, currY - startY);
        });

        roiCanvas.addEventListener('mouseup', e => {
            if (!isSelectingRoi || !isRoiMode) return;
            isSelectingRoi = false;

            const rect = roiCanvas.getBoundingClientRect();
            const currX = e.clientX - rect.left;
            const currY = e.clientY - rect.top;

            let x = Math.min(startX, currX);
            let y = Math.min(startY, currY);
            let w = Math.abs(currX - startX);
            let h = Math.abs(currY - startY);

            if (w > 10 && h > 10) {
                roiRect = {
                    x: Math.max(0, x / roiCanvas.width),
                    y: Math.max(0, y / roiCanvas.height),
                    w: Math.min(1, w / roiCanvas.width),
                    h: Math.min(1, h / roiCanvas.height)
                };
                // Clamp width/height
                roiRect.w = Math.min(1 - roiRect.x, roiRect.w);
                roiRect.h = Math.min(1 - roiRect.y, roiRect.h);

                document.getElementById('roiInfo').textContent = `ROI: ${Math.round(roiRect.w * 100)}% x ${Math.round(roiRect.h * 100)}%`;
            } else {
                roiRect = null;
                document.getElementById('roiInfo').textContent = `ROI: Ï†ÑÏ≤¥ ÌôîÎ©¥`;
            }
            drawRoiBox();
        });

        function drawRoiBox() {
            const ctx = roiCanvas.getContext('2d');
            ctx.clearRect(0, 0, roiCanvas.width, roiCanvas.height);
            if (roiRect) {
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(
                    roiRect.x * roiCanvas.width,
                    roiRect.y * roiCanvas.height,
                    roiRect.w * roiCanvas.width,
                    roiRect.h * roiCanvas.height
                );
                ctx.setLineDash([]);
            }
        }

        // --- Timepoint Logic ---
        function addTimepoint() {
            if (!video.src) return;
            const time = video.currentTime;
            if (!timepoints.some(t => Math.abs(t - time) < 0.1)) {
                timepoints.push(time);
                timepoints.sort((a, b) => a - b);
                updateTags();
            }
        }

        function clearAll() {
            timepoints = [];
            updateTags();
            roiRect = null;
            drawRoiBox();
        }

        function updateTags() {
            const container = currentMode === 'event' ? document.getElementById('tagsContainer') : document.getElementById('phaseTagsContainer');
            const countId = currentMode === 'event' ? 'tagCount' : 'phaseTagCount';

            document.getElementById(countId).textContent = timepoints.length;
            container.innerHTML = '';

            timepoints.forEach((time, index) => {
                const div = document.createElement('div');
                div.className = 'tag-item';
                div.innerHTML = `<span onclick="video.currentTime=${time}">${time.toFixed(2)}s</span> <span class="remove-btn" onclick="removeTimepoint(${index})">√ó</span>`;
                container.appendChild(div);
            });

            document.getElementById('toStep2Btn').style.display = timepoints.length > 0 ? 'block' : 'none';
        }

        function removeTimepoint(index) {
            timepoints.splice(index, 1);
            updateTags();
        }

        // --- Phase Logic ---
        function setExtractStart() { document.getElementById('extractStart').value = video.currentTime.toFixed(2); updatePhaseInfos(); }
        function setExtractEnd() { document.getElementById('extractEnd').value = video.currentTime.toFixed(2); updatePhaseInfos(); }
        function setPhaseStart() { document.getElementById('startTime').value = video.currentTime.toFixed(2); updatePhaseInfos(); }
        function setPhaseEnd() { document.getElementById('endTime').value = video.currentTime.toFixed(2); updatePhaseInfos(); }

        function updatePhaseInfos() {
            // Extract Info
            const eStart = parseFloat(document.getElementById('extractStart').value) || 0;
            const eEnd = parseFloat(document.getElementById('extractEnd').value) || 0;
            const eInfo = document.getElementById('extractInfo');
            if (eStart >= eEnd) { eInfo.innerHTML = '‚ö†Ô∏è ÏãúÏûë ÏãúÍ∞ÑÏù¥ Ï¢ÖÎ£å ÏãúÍ∞ÑÎ≥¥Îã§ ÏûëÏïÑÏïº Ìï©ÎãàÎã§.'; }
            else { eInfo.innerHTML = `üí° ÏµúÏ¢Ö ÏòÅÏÉÅ Íµ¨Í∞Ñ: ${eStart}s ~ ${eEnd}s (${(eEnd - eStart).toFixed(2)}s)`; }

            // Phase Info
            const pStart = parseFloat(document.getElementById('startTime').value) || 0;
            const pEnd = parseFloat(document.getElementById('endTime').value) || 0;
            const interval = parseInt(document.getElementById('frameInterval').value) || 15;
            const fps = 30; // Approx
            const pInfo = document.getElementById('phaseInfo');

            const count = Math.floor(((pEnd - pStart) * fps) / interval) + 1;
            if (pStart >= pEnd) { pInfo.innerHTML = '‚ö†Ô∏è ÏÑ§Ï†ï Ïò§Î•ò'; }
            else { pInfo.innerHTML = `üí° ÏòàÏÉÅ ÏãúÏ†ê Ïàò: ÏïΩ ${count}Í∞ú (Í∞ÑÍ≤©: ${(interval / 30).toFixed(2)}s)`; }
        }

        function generatePhasePoints() {
            const start = parseFloat(document.getElementById('startTime').value) || 0;
            const end = parseFloat(document.getElementById('endTime').value) || 0;
            const interval = parseInt(document.getElementById('frameInterval').value) || 15;
            const fps = 30;

            if (start >= end) return alert('ÏãúÍ∞Ñ ÏÑ§Ï†ïÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî');

            timepoints = [];
            const step = interval / fps;
            for (let t = start; t <= end; t += step) {
                timepoints.push(parseFloat(t.toFixed(2)));
            }
            updateTags();
        }

        ['extractStart', 'extractEnd', 'startTime', 'endTime', 'frameInterval'].forEach(id => {
            document.getElementById(id).addEventListener('input', updatePhaseInfos);
        });

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && video.src && document.getElementById('step1-content').style.display !== 'none') {
                e.preventDefault();
                video.paused ? video.play() : (video.pause(), currentMode === 'event' ? addTimepoint() : null);
            }
        });

        // --- Step 2 & Process ---
        async function goToStep2() {
            if (!cvReady) return alert('OpenCV Î°úÎî© Ï§ëÏûÖÎãàÎã§.');

            showLoading('ÌîÑÎ†àÏûÑ Ï∂îÏ∂ú Ï§ë...');

            try {
                // Background: Frame 0
                video.currentTime = 0;
                await waitForSeek();
                backgroundFrameData = await captureFrame();

                frameDataList = [];
                for (let i = 0; i < timepoints.length; i++) {
                    video.currentTime = timepoints[i];
                    await waitForSeek();
                    const data = await captureFrame();
                    frameDataList.push({ time: timepoints[i], data: data });
                    updateProgress((i + 1) / timepoints.length * 100);
                }

                hideLoading();

                document.getElementById('step1-content').style.display = 'none';
                document.getElementById('step2-content').style.display = 'block';
                document.getElementById('step1-dot').classList.remove('active');
                document.getElementById('step2-dot').classList.add('active');

                setTimeout(updatePreview, 100);

            } catch (e) {
                console.error(e);
                hideLoading();
                alert('Ïò§Î•ò: ' + e);
            }
        }

        function goToStep1() {
            document.getElementById('step2-content').style.display = 'none';
            document.getElementById('step1-content').style.display = 'block';
            document.getElementById('step2-dot').classList.remove('active');
            document.getElementById('step1-dot').classList.add('active');
        }

        function captureFrame() {
            const c = document.createElement('canvas');
            c.width = video.videoWidth; c.height = video.videoHeight;
            c.getContext('2d').drawImage(video, 0, 0);
            return Promise.resolve(c.getContext('2d').getImageData(0, 0, c.width, c.height));
        }

        function waitForSeek() {
            return new Promise(resolve => {
                const h = () => { video.removeEventListener('seeked', h); resolve(); };
                video.addEventListener('seeked', h);
                // Safety
                setTimeout(() => { video.removeEventListener('seeked', h); resolve(); }, 1500);
            });
        }

        function showLoading(msg) {
            document.getElementById('loadingOverlay').style.display = 'flex';
            document.getElementById('loadingText').textContent = msg;
        }
        function hideLoading() {
            document.getElementById('loadingOverlay').style.display = 'none';
        }
        function updateProgress(p) {
            document.getElementById('progressFill').style.width = p + '%';
            document.getElementById('progressText').textContent = Math.round(p) + '%';
        }

        // --- OpenCV Processing ---
        function processFrame(srcData, bgData, threshold, morphIter) {
            let src = null, bg = null, srcYCrCb = null, bgYCrCb = null, diff = null;
            let channels = null, mask = null, t1 = null, t2 = null;
            let contours = null, hierarchy = null, M = null;

            try {
                src = cv.matFromImageData(srcData);
                bg = cv.matFromImageData(bgData);

                // 1. Downsample (50%)
                let dsize = new cv.Size(Math.round(src.cols * 0.5), Math.round(src.rows * 0.5));
                cv.resize(src, src, dsize, 0, 0, cv.INTER_AREA);
                cv.resize(bg, bg, dsize, 0, 0, cv.INTER_AREA);

                // 2. ROI
                let w = src.cols, h = src.rows;
                let roiX = 0, roiY = 0;

                if (roiRect) {
                    roiX = Math.floor(roiRect.x * w);
                    roiY = Math.floor(roiRect.y * h);
                    let rw = Math.floor(roiRect.w * w);
                    let rh = Math.floor(roiRect.h * h);
                    // Clamp
                    rw = Math.max(1, Math.min(rw, w - roiX));
                    rh = Math.max(1, Math.min(rh, h - roiY));

                    let rect = new cv.Rect(roiX, roiY, rw, rh);
                    let sRoi = src.roi(rect);
                    let bRoi = bg.roi(rect);
                    src.delete(); bg.delete(); // Delete parents (JS binding nuance: usually safe if not referencing elsewhere)
                    src = sRoi; bg = bRoi;
                }

                // 3. YCbCr Diff
                srcYCrCb = new cv.Mat(); bgYCrCb = new cv.Mat();
                cv.cvtColor(src, srcYCrCb, cv.COLOR_RGB2YCrCb);
                cv.cvtColor(bg, bgYCrCb, cv.COLOR_RGB2YCrCb);

                diff = new cv.Mat();
                cv.absdiff(srcYCrCb, bgYCrCb, diff);

                channels = new cv.MatVector();
                cv.split(diff, channels);

                // 4. Threshold (Cb/Cr only for chromatic objects, robust to shadow)
                mask = new cv.Mat(); t1 = new cv.Mat(); t2 = new cv.Mat();
                cv.threshold(channels.get(1), t1, threshold, 255, cv.THRESH_BINARY);
                cv.threshold(channels.get(2), t2, threshold, 255, cv.THRESH_BINARY);
                cv.bitwise_or(t1, t2, mask);

                // 5. Morphology
                M = cv.Mat.ones(3, 3, cv.CV_8U);
                let anchor = new cv.Point(-1, -1);
                cv.morphologyEx(mask, mask, cv.MORPH_OPEN, M, anchor, morphIter);
                cv.morphologyEx(mask, mask, cv.MORPH_CLOSE, M, anchor, morphIter);

                // 6. Contours
                contours = new cv.MatVector();
                hierarchy = new cv.Mat();
                cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                let maxArea = 0, maxIdx = -1;
                for (let i = 0; i < contours.size(); i++) {
                    let a = cv.contourArea(contours.get(i));
                    if (a > maxArea) { maxArea = a; maxIdx = i; }
                }

                let result = { found: false, scale: 2.0, roiOffset: { x: roiX, y: roiY } };

                if (maxIdx !== -1 && maxArea > 30) {
                    result.found = true;
                    let cnt = contours.get(maxIdx);
                    let rr = cv.minAreaRect(cnt);
                    result.center = rr.center;

                    let pts = cv.RotatedRect.points(rr);
                    // Major axis
                    let d1 = dist(pts[0], pts[1]);
                    let d2 = dist(pts[1], pts[2]);
                    if (d2 > d1) {
                        result.p1 = mid(pts[0], pts[1]);
                        result.p2 = mid(pts[2], pts[3]);
                    } else {
                        result.p1 = mid(pts[1], pts[2]);
                        result.p2 = mid(pts[3], pts[0]);
                    }
                }

                return result;

            } catch (e) {
                console.error(e);
                return { found: false };
            } finally {
                if (src && !src.isDeleted()) src.delete();
                if (bg && !bg.isDeleted()) bg.delete();
                if (srcYCrCb) srcYCrCb.delete();
                if (bgYCrCb) bgYCrCb.delete();
                if (diff) diff.delete();
                if (channels) channels.delete();
                if (mask) mask.delete();
                if (t1) t1.delete();
                if (t2) t2.delete();
                if (contours) contours.delete();
                if (hierarchy) hierarchy.delete();
                if (M) M.delete();
            }
        }

        function dist(p1, p2) { return Math.hypot(p1.x - p2.x, p1.y - p2.y); }
        function mid(p1, p2) { return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 }; }

        function updatePreview() {
            if (frameDataList.length === 0) return;
            const thresh = parseInt(document.getElementById('thresholdRange').value);
            const morph = parseInt(document.getElementById('morphRange').value);
            document.getElementById('threshVal').textContent = thresh;
            document.getElementById('morphVal').textContent = morph;

            const res = processFrame(frameDataList[0].data, backgroundFrameData, thresh, morph);

            const cvs = document.getElementById('previewProc');
            cvs.width = video.videoWidth; cvs.height = video.videoHeight;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = 'black'; ctx.fillRect(0, 0, cvs.width, cvs.height);

            if (res.found) drawFeature(ctx, res);

            const rC = document.getElementById('previewRoi');
            rC.width = video.videoWidth; rC.height = video.videoHeight;
            const rCtx = rC.getContext('2d');
            rCtx.putImageData(frameDataList[0].data, 0, 0);
            if (roiRect) {
                rCtx.strokeStyle = 'yellow'; rCtx.lineWidth = 4;
                rCtx.strokeRect(roiRect.x * rC.width, roiRect.y * rC.height, roiRect.w * rC.width, roiRect.h * rC.height);
            }
        }

        function drawFeature(ctx, res) {
            const sc = res.scale;
            const ox = res.roiOffset.x;
            const oy = res.roiOffset.y;
            const tr = p => ({ x: (p.x * sc) + (ox * sc), y: (p.y * sc) + (oy * sc) });

            if (res.p1 && res.p2) {
                const p1 = tr(res.p1); const p2 = tr(res.p2);
                ctx.strokeStyle = '#00ff00'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();

                ctx.fillStyle = 'red';
                ctx.beginPath(); ctx.arc(p1.x, p1.y, 5, 0, 6.28); ctx.fill();
                ctx.beginPath(); ctx.arc(p2.x, p2.y, 5, 0, 6.28); ctx.fill();
            }
        }

        function generateResult() {
            showLoading('Í≤∞Í≥º ÏÉùÏÑ± Ï§ë...');
            setTimeout(() => {
                const thresh = parseInt(document.getElementById('thresholdRange').value);
                const morph = parseInt(document.getElementById('morphRange').value);

                const canvas = document.getElementById('finalCanvas');
                canvas.width = video.videoWidth; canvas.height = video.videoHeight;
                const ctx = canvas.getContext('2d');

                // Draw BG
                const t = document.createElement('canvas'); t.width = canvas.width; t.height = canvas.height;
                t.getContext('2d').putImageData(backgroundFrameData, 0, 0);
                ctx.drawImage(t, 0, 0);

                frameDataList.forEach((fd, idx) => {
                    const res = processFrame(fd.data, backgroundFrameData, thresh, morph);
                    if (res.found) {
                        const sc = res.scale;
                        const ox = res.roiOffset.x;
                        const oy = res.roiOffset.y;
                        const tr = p => ({ x: (p.x * sc) + (ox * sc), y: (p.y * sc) + (oy * sc) });

                        const ratio = idx / frameDataList.length;
                        if (res.p1 && res.p2) {
                            const p1 = tr(res.p1); const p2 = tr(res.p2);
                            ctx.strokeStyle = `hsla(${ratio * 300}, 100%, 50%, 0.8)`;
                            ctx.lineWidth = 3;
                            ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
                        }
                    }
                });

                hideLoading();
                document.getElementById('step2-content').style.display = 'none';
                document.getElementById('step3-content').style.display = 'block';
                document.getElementById('step2-dot').classList.remove('active');
                document.getElementById('step3-dot').classList.add('active');
            }, 50);
        }

        function downloadImage() {
            const a = document.createElement('a');
            a.download = 'phase_analysis.png';
            a.href = document.getElementById('finalCanvas').toDataURL();
            a.click();
        }
    </script>
</body>

</html>